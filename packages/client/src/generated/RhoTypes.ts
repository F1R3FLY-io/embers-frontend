// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.7.7
//   protoc               v3.21.12
// source: RhoTypes.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";

export const protobufPackage = "rhoapi";

/**
 * Rholang Term Structure
 *
 * The top level is `Par`.
 */

/**
 * Rholang process
 *
 * For example, `@0!(1) | @2!(3) | for(x <- @0) { Nil }` has two sends
 * and one receive.
 *
 * The Nil process is a `Par` with no sends, receives, etc.
 */
export interface Par {
  sends: Send[];
  receives: Receive[];
  news: New[];
  exprs: Expr[];
  matches: Match[];
  /** unforgeable names */
  unforgeables: GUnforgeable[];
  bundles: Bundle[];
  connectives: Connective[];
  locallyFree: Uint8Array;
  connectiveUsed: boolean;
}

/** Either rholang code or code built in to the interpreter. */
export interface TaggedContinuation {
  parBody?: ParWithRandom | undefined;
  scalaBodyRef?: number | undefined;
}

/**
 * Rholang code along with the state of a split random number
 * generator for generating new unforgeable names.
 */
export interface ParWithRandom {
  body: Par | undefined;
  randomState: Uint8Array;
}

/** Cost of the performed operations. */
export interface PCost {
  cost: number;
}

export interface ListParWithRandom {
  pars: Par[];
  randomState: Uint8Array;
}

/**
 * While we use vars in both positions, when producing the normalized
 * representation we need a discipline to track whether a var is a name or a
 * process.
 * These are DeBruijn levels
 */
export interface Var {
  boundVar?: number | undefined;
  freeVar?: number | undefined;
  wildcard?: Var_WildcardMsg | undefined;
}

export interface Var_WildcardMsg {}

/**
 * Nothing can be received from a (quoted) bundle with `readFlag = false`.
 * Likeise nothing can be sent to a (quoted) bundle with `writeFlag = false`.
 *
 * If both flags are set to false, bundle allows only for equivalance check.
 */
export interface Bundle {
  body: Par | undefined;
  /** flag indicating whether bundle is writeable */
  writeFlag: boolean;
  /** flag indicating whether bundle is readable */
  readFlag: boolean;
}

/**
 * A send is written `chan!(data)` or `chan!!(data)` for a persistent send.
 *
 * Upon send, all free variables in data are substituted with their values.
 */
export interface Send {
  chan: Par | undefined;
  data: Par[];
  persistent: boolean;
  locallyFree: Uint8Array;
  connectiveUsed: boolean;
}

export interface ReceiveBind {
  patterns: Par[];
  source: Par | undefined;
  remainder: Var | undefined;
  freeCount: number;
}

export interface BindPattern {
  patterns: Par[];
  remainder: Var | undefined;
  freeCount: number;
}

export interface ListBindPatterns {
  patterns: BindPattern[];
}

/**
 * A receive is written `for(binds) { body }`
 * i.e. `for(patterns <- source) { body }`
 * or for a persistent recieve: `for(patterns <= source) { body }`.
 *
 * It's an error for free Variable to occur more than once in a pattern.
 */
export interface Receive {
  binds: ReceiveBind[];
  body: Par | undefined;
  persistent: boolean;
  peek: boolean;
  bindCount: number;
  locallyFree: Uint8Array;
  connectiveUsed: boolean;
}

/**
 * Number of variables bound in the new statement.
 * For normalized form, p should not contain solely another new.
 * Also for normalized form, the first use should be level+0, next use level+1
 * up to level+count for the last used variable.
 */
export interface New {
  /** Includes any uris listed below. This makes it easier to substitute or walk a term. */
  bindCount: number;
  p: Par | undefined;
  /** For normalization, uri-referenced variables come at the end, and in lexicographical order. */
  uri: string[];
  injections: { [key: string]: Par };
  locallyFree: Uint8Array;
}

export interface New_InjectionsEntry {
  key: string;
  value: Par | undefined;
}

export interface MatchCase {
  pattern: Par | undefined;
  source: Par | undefined;
  freeCount: number;
}

export interface Match {
  target: Par | undefined;
  cases: MatchCase[];
  locallyFree: Uint8Array;
  connectiveUsed: boolean;
}

/**
 * Any process may be an operand to an expression.
 * Only processes equivalent to a ground process of compatible type will reduce.
 */
export interface Expr {
  gBool?: boolean | undefined;
  gInt?: number | undefined;
  gString?: string | undefined;
  gUri?: string | undefined;
  gByteArray?: Uint8Array | undefined;
  eNotBody?: ENot | undefined;
  eNegBody?: ENeg | undefined;
  eMultBody?: EMult | undefined;
  eDivBody?: EDiv | undefined;
  ePlusBody?: EPlus | undefined;
  eMinusBody?: EMinus | undefined;
  eLtBody?: ELt | undefined;
  eLteBody?: ELte | undefined;
  eGtBody?: EGt | undefined;
  eGteBody?: EGte | undefined;
  eEqBody?: EEq | undefined;
  eNeqBody?: ENeq | undefined;
  eAndBody?: EAnd | undefined;
  eOrBody?: EOr | undefined;
  eVarBody?: EVar | undefined;
  eListBody?: EList | undefined;
  eTupleBody?: ETuple | undefined;
  eSetBody?: ESet | undefined;
  eMapBody?: EMap | undefined;
  eMethodBody?: EMethod | undefined;
  eMatchesBody?: EMatches | undefined;
  /** string interpolation */
  ePercentPercentBody?: EPercentPercent | undefined;
  /** concatenation */
  ePlusPlusBody?: EPlusPlus | undefined;
  /** set difference */
  eMinusMinusBody?: EMinusMinus | undefined;
  eModBody?: EMod | undefined;
}

export interface EList {
  ps: Par[];
  locallyFree: Uint8Array;
  connectiveUsed: boolean;
  remainder: Var | undefined;
}

export interface ETuple {
  ps: Par[];
  locallyFree: Uint8Array;
  connectiveUsed: boolean;
}

export interface ESet {
  ps: Par[];
  locallyFree: Uint8Array;
  connectiveUsed: boolean;
  remainder: Var | undefined;
}

export interface EMap {
  kvs: KeyValuePair[];
  locallyFree: Uint8Array;
  connectiveUsed: boolean;
  remainder: Var | undefined;
}

/** `target.method(arguments)` */
export interface EMethod {
  methodName: string;
  target: Par | undefined;
  arguments: Par[];
  locallyFree: Uint8Array;
  connectiveUsed: boolean;
}

export interface KeyValuePair {
  key: Par | undefined;
  value: Par | undefined;
}

/**
 * A variable used as a var should be bound in a process context, not a name
 * context. For example:
 * `for (@x <- c1; @y <- c2) { z!(x + y) }` is fine, but
 * `for (x <- c1; y <- c2) { z!(x + y) }` should raise an error.
 */
export interface EVar {
  v: Var | undefined;
}

export interface ENot {
  p: Par | undefined;
}

export interface ENeg {
  p: Par | undefined;
}

export interface EMult {
  p1: Par | undefined;
  p2: Par | undefined;
}

export interface EDiv {
  p1: Par | undefined;
  p2: Par | undefined;
}

export interface EMod {
  p1: Par | undefined;
  p2: Par | undefined;
}

export interface EPlus {
  p1: Par | undefined;
  p2: Par | undefined;
}

export interface EMinus {
  p1: Par | undefined;
  p2: Par | undefined;
}

export interface ELt {
  p1: Par | undefined;
  p2: Par | undefined;
}

export interface ELte {
  p1: Par | undefined;
  p2: Par | undefined;
}

export interface EGt {
  p1: Par | undefined;
  p2: Par | undefined;
}

export interface EGte {
  p1: Par | undefined;
  p2: Par | undefined;
}

export interface EEq {
  p1: Par | undefined;
  p2: Par | undefined;
}

export interface ENeq {
  p1: Par | undefined;
  p2: Par | undefined;
}

export interface EAnd {
  p1: Par | undefined;
  p2: Par | undefined;
}

export interface EOr {
  p1: Par | undefined;
  p2: Par | undefined;
}

export interface EMatches {
  target: Par | undefined;
  pattern: Par | undefined;
}

/**
 * String interpolation
 *
 * `"Hello, {name}" %% {"name": "Bob"}` denotes `"Hello, Bob"`
 */
export interface EPercentPercent {
  p1: Par | undefined;
  p2: Par | undefined;
}

/** Concatenation */
export interface EPlusPlus {
  p1: Par | undefined;
  p2: Par | undefined;
}

/** Set difference */
export interface EMinusMinus {
  p1: Par | undefined;
  p2: Par | undefined;
}

export interface Connective {
  connAndBody?: ConnectiveBody | undefined;
  connOrBody?: ConnectiveBody | undefined;
  connNotBody?: Par | undefined;
  varRefBody?: VarRef | undefined;
  connBool?: boolean | undefined;
  connInt?: boolean | undefined;
  connString?: boolean | undefined;
  connUri?: boolean | undefined;
  connByteArray?: boolean | undefined;
}

export interface VarRef {
  index: number;
  depth: number;
}

export interface ConnectiveBody {
  ps: Par[];
}

export interface DeployId {
  sig: Uint8Array;
}

export interface DeployerId {
  publicKey: Uint8Array;
}

/**
 * Unforgeable names resulting from `new x { ... }`
 * These should only occur as the program is being evaluated. There is no way in
 * the grammar to construct them.
 */
export interface GUnforgeable {
  gPrivateBody?: GPrivate | undefined;
  gDeployIdBody?: GDeployId | undefined;
  gDeployerIdBody?: GDeployerId | undefined;
  gSysAuthTokenBody?: GSysAuthToken | undefined;
}

export interface GPrivate {
  id: Uint8Array;
}

export interface GDeployId {
  sig: Uint8Array;
}

export interface GDeployerId {
  publicKey: Uint8Array;
}

export interface GSysAuthToken {}

function createBasePar(): Par {
  return {
    sends: [],
    receives: [],
    news: [],
    exprs: [],
    matches: [],
    unforgeables: [],
    bundles: [],
    connectives: [],
    locallyFree: new Uint8Array(0),
    connectiveUsed: false,
  };
}

export const Par: MessageFns<Par> = {
  encode(
    message: Par,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    for (const v of message.sends) {
      Send.encode(v!, writer.uint32(10).fork()).join();
    }
    for (const v of message.receives) {
      Receive.encode(v!, writer.uint32(18).fork()).join();
    }
    for (const v of message.news) {
      New.encode(v!, writer.uint32(34).fork()).join();
    }
    for (const v of message.exprs) {
      Expr.encode(v!, writer.uint32(42).fork()).join();
    }
    for (const v of message.matches) {
      Match.encode(v!, writer.uint32(50).fork()).join();
    }
    for (const v of message.unforgeables) {
      GUnforgeable.encode(v!, writer.uint32(58).fork()).join();
    }
    for (const v of message.bundles) {
      Bundle.encode(v!, writer.uint32(90).fork()).join();
    }
    for (const v of message.connectives) {
      Connective.encode(v!, writer.uint32(66).fork()).join();
    }
    if (message.locallyFree.length !== 0) {
      writer.uint32(74).bytes(message.locallyFree);
    }
    if (message.connectiveUsed !== false) {
      writer.uint32(80).bool(message.connectiveUsed);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Par {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePar();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.sends.push(Send.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.receives.push(Receive.decode(reader, reader.uint32()));
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.news.push(New.decode(reader, reader.uint32()));
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.exprs.push(Expr.decode(reader, reader.uint32()));
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.matches.push(Match.decode(reader, reader.uint32()));
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.unforgeables.push(
            GUnforgeable.decode(reader, reader.uint32()),
          );
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.bundles.push(Bundle.decode(reader, reader.uint32()));
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.connectives.push(Connective.decode(reader, reader.uint32()));
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.locallyFree = reader.bytes();
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }

          message.connectiveUsed = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Par {
    return {
      sends: globalThis.Array.isArray(object?.sends)
        ? object.sends.map((e: any) => Send.fromJSON(e))
        : [],
      receives: globalThis.Array.isArray(object?.receives)
        ? object.receives.map((e: any) => Receive.fromJSON(e))
        : [],
      news: globalThis.Array.isArray(object?.news)
        ? object.news.map((e: any) => New.fromJSON(e))
        : [],
      exprs: globalThis.Array.isArray(object?.exprs)
        ? object.exprs.map((e: any) => Expr.fromJSON(e))
        : [],
      matches: globalThis.Array.isArray(object?.matches)
        ? object.matches.map((e: any) => Match.fromJSON(e))
        : [],
      unforgeables: globalThis.Array.isArray(object?.unforgeables)
        ? object.unforgeables.map((e: any) => GUnforgeable.fromJSON(e))
        : [],
      bundles: globalThis.Array.isArray(object?.bundles)
        ? object.bundles.map((e: any) => Bundle.fromJSON(e))
        : [],
      connectives: globalThis.Array.isArray(object?.connectives)
        ? object.connectives.map((e: any) => Connective.fromJSON(e))
        : [],
      locallyFree: isSet(object.locallyFree)
        ? bytesFromBase64(object.locallyFree)
        : new Uint8Array(0),
      connectiveUsed: isSet(object.connectiveUsed)
        ? globalThis.Boolean(object.connectiveUsed)
        : false,
    };
  },

  toJSON(message: Par): unknown {
    const obj: any = {};
    if (message.sends?.length) {
      obj.sends = message.sends.map((e) => Send.toJSON(e));
    }
    if (message.receives?.length) {
      obj.receives = message.receives.map((e) => Receive.toJSON(e));
    }
    if (message.news?.length) {
      obj.news = message.news.map((e) => New.toJSON(e));
    }
    if (message.exprs?.length) {
      obj.exprs = message.exprs.map((e) => Expr.toJSON(e));
    }
    if (message.matches?.length) {
      obj.matches = message.matches.map((e) => Match.toJSON(e));
    }
    if (message.unforgeables?.length) {
      obj.unforgeables = message.unforgeables.map((e) =>
        GUnforgeable.toJSON(e),
      );
    }
    if (message.bundles?.length) {
      obj.bundles = message.bundles.map((e) => Bundle.toJSON(e));
    }
    if (message.connectives?.length) {
      obj.connectives = message.connectives.map((e) => Connective.toJSON(e));
    }
    if (message.locallyFree.length !== 0) {
      obj.locallyFree = base64FromBytes(message.locallyFree);
    }
    if (message.connectiveUsed !== false) {
      obj.connectiveUsed = message.connectiveUsed;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Par>, I>>(base?: I): Par {
    return Par.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Par>, I>>(object: I): Par {
    const message = createBasePar();
    message.sends = object.sends?.map((e) => Send.fromPartial(e)) || [];
    message.receives =
      object.receives?.map((e) => Receive.fromPartial(e)) || [];
    message.news = object.news?.map((e) => New.fromPartial(e)) || [];
    message.exprs = object.exprs?.map((e) => Expr.fromPartial(e)) || [];
    message.matches = object.matches?.map((e) => Match.fromPartial(e)) || [];
    message.unforgeables =
      object.unforgeables?.map((e) => GUnforgeable.fromPartial(e)) || [];
    message.bundles = object.bundles?.map((e) => Bundle.fromPartial(e)) || [];
    message.connectives =
      object.connectives?.map((e) => Connective.fromPartial(e)) || [];
    message.locallyFree = object.locallyFree ?? new Uint8Array(0);
    message.connectiveUsed = object.connectiveUsed ?? false;
    return message;
  },
};

function createBaseTaggedContinuation(): TaggedContinuation {
  return { parBody: undefined, scalaBodyRef: undefined };
}

export const TaggedContinuation: MessageFns<TaggedContinuation> = {
  encode(
    message: TaggedContinuation,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.parBody !== undefined) {
      ParWithRandom.encode(message.parBody, writer.uint32(10).fork()).join();
    }
    if (message.scalaBodyRef !== undefined) {
      writer.uint32(16).int64(message.scalaBodyRef);
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): TaggedContinuation {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTaggedContinuation();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.parBody = ParWithRandom.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.scalaBodyRef = longToNumber(reader.int64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TaggedContinuation {
    return {
      parBody: isSet(object.parBody)
        ? ParWithRandom.fromJSON(object.parBody)
        : undefined,
      scalaBodyRef: isSet(object.scalaBodyRef)
        ? globalThis.Number(object.scalaBodyRef)
        : undefined,
    };
  },

  toJSON(message: TaggedContinuation): unknown {
    const obj: any = {};
    if (message.parBody !== undefined) {
      obj.parBody = ParWithRandom.toJSON(message.parBody);
    }
    if (message.scalaBodyRef !== undefined) {
      obj.scalaBodyRef = Math.round(message.scalaBodyRef);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TaggedContinuation>, I>>(
    base?: I,
  ): TaggedContinuation {
    return TaggedContinuation.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TaggedContinuation>, I>>(
    object: I,
  ): TaggedContinuation {
    const message = createBaseTaggedContinuation();
    message.parBody =
      object.parBody !== undefined && object.parBody !== null
        ? ParWithRandom.fromPartial(object.parBody)
        : undefined;
    message.scalaBodyRef = object.scalaBodyRef ?? undefined;
    return message;
  },
};

function createBaseParWithRandom(): ParWithRandom {
  return { body: undefined, randomState: new Uint8Array(0) };
}

export const ParWithRandom: MessageFns<ParWithRandom> = {
  encode(
    message: ParWithRandom,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.body !== undefined) {
      Par.encode(message.body, writer.uint32(10).fork()).join();
    }
    if (message.randomState.length !== 0) {
      writer.uint32(18).bytes(message.randomState);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ParWithRandom {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseParWithRandom();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.body = Par.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.randomState = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ParWithRandom {
    return {
      body: isSet(object.body) ? Par.fromJSON(object.body) : undefined,
      randomState: isSet(object.randomState)
        ? bytesFromBase64(object.randomState)
        : new Uint8Array(0),
    };
  },

  toJSON(message: ParWithRandom): unknown {
    const obj: any = {};
    if (message.body !== undefined) {
      obj.body = Par.toJSON(message.body);
    }
    if (message.randomState.length !== 0) {
      obj.randomState = base64FromBytes(message.randomState);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ParWithRandom>, I>>(
    base?: I,
  ): ParWithRandom {
    return ParWithRandom.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ParWithRandom>, I>>(
    object: I,
  ): ParWithRandom {
    const message = createBaseParWithRandom();
    message.body =
      object.body !== undefined && object.body !== null
        ? Par.fromPartial(object.body)
        : undefined;
    message.randomState = object.randomState ?? new Uint8Array(0);
    return message;
  },
};

function createBasePCost(): PCost {
  return { cost: 0 };
}

export const PCost: MessageFns<PCost> = {
  encode(
    message: PCost,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.cost !== 0) {
      writer.uint32(8).uint64(message.cost);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PCost {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePCost();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.cost = longToNumber(reader.uint64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PCost {
    return { cost: isSet(object.cost) ? globalThis.Number(object.cost) : 0 };
  },

  toJSON(message: PCost): unknown {
    const obj: any = {};
    if (message.cost !== 0) {
      obj.cost = Math.round(message.cost);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PCost>, I>>(base?: I): PCost {
    return PCost.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PCost>, I>>(object: I): PCost {
    const message = createBasePCost();
    message.cost = object.cost ?? 0;
    return message;
  },
};

function createBaseListParWithRandom(): ListParWithRandom {
  return { pars: [], randomState: new Uint8Array(0) };
}

export const ListParWithRandom: MessageFns<ListParWithRandom> = {
  encode(
    message: ListParWithRandom,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    for (const v of message.pars) {
      Par.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.randomState.length !== 0) {
      writer.uint32(18).bytes(message.randomState);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListParWithRandom {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListParWithRandom();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.pars.push(Par.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.randomState = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListParWithRandom {
    return {
      pars: globalThis.Array.isArray(object?.pars)
        ? object.pars.map((e: any) => Par.fromJSON(e))
        : [],
      randomState: isSet(object.randomState)
        ? bytesFromBase64(object.randomState)
        : new Uint8Array(0),
    };
  },

  toJSON(message: ListParWithRandom): unknown {
    const obj: any = {};
    if (message.pars?.length) {
      obj.pars = message.pars.map((e) => Par.toJSON(e));
    }
    if (message.randomState.length !== 0) {
      obj.randomState = base64FromBytes(message.randomState);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListParWithRandom>, I>>(
    base?: I,
  ): ListParWithRandom {
    return ListParWithRandom.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListParWithRandom>, I>>(
    object: I,
  ): ListParWithRandom {
    const message = createBaseListParWithRandom();
    message.pars = object.pars?.map((e) => Par.fromPartial(e)) || [];
    message.randomState = object.randomState ?? new Uint8Array(0);
    return message;
  },
};

function createBaseVar(): Var {
  return { boundVar: undefined, freeVar: undefined, wildcard: undefined };
}

export const Var: MessageFns<Var> = {
  encode(
    message: Var,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.boundVar !== undefined) {
      writer.uint32(8).sint32(message.boundVar);
    }
    if (message.freeVar !== undefined) {
      writer.uint32(16).sint32(message.freeVar);
    }
    if (message.wildcard !== undefined) {
      Var_WildcardMsg.encode(message.wildcard, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Var {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVar();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.boundVar = reader.sint32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.freeVar = reader.sint32();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.wildcard = Var_WildcardMsg.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Var {
    return {
      boundVar: isSet(object.boundVar)
        ? globalThis.Number(object.boundVar)
        : undefined,
      freeVar: isSet(object.freeVar)
        ? globalThis.Number(object.freeVar)
        : undefined,
      wildcard: isSet(object.wildcard)
        ? Var_WildcardMsg.fromJSON(object.wildcard)
        : undefined,
    };
  },

  toJSON(message: Var): unknown {
    const obj: any = {};
    if (message.boundVar !== undefined) {
      obj.boundVar = Math.round(message.boundVar);
    }
    if (message.freeVar !== undefined) {
      obj.freeVar = Math.round(message.freeVar);
    }
    if (message.wildcard !== undefined) {
      obj.wildcard = Var_WildcardMsg.toJSON(message.wildcard);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Var>, I>>(base?: I): Var {
    return Var.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Var>, I>>(object: I): Var {
    const message = createBaseVar();
    message.boundVar = object.boundVar ?? undefined;
    message.freeVar = object.freeVar ?? undefined;
    message.wildcard =
      object.wildcard !== undefined && object.wildcard !== null
        ? Var_WildcardMsg.fromPartial(object.wildcard)
        : undefined;
    return message;
  },
};

function createBaseVar_WildcardMsg(): Var_WildcardMsg {
  return {};
}

export const Var_WildcardMsg: MessageFns<Var_WildcardMsg> = {
  encode(
    _: Var_WildcardMsg,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Var_WildcardMsg {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVar_WildcardMsg();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): Var_WildcardMsg {
    return {};
  },

  toJSON(_: Var_WildcardMsg): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<Var_WildcardMsg>, I>>(
    base?: I,
  ): Var_WildcardMsg {
    return Var_WildcardMsg.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Var_WildcardMsg>, I>>(
    _: I,
  ): Var_WildcardMsg {
    const message = createBaseVar_WildcardMsg();
    return message;
  },
};

function createBaseBundle(): Bundle {
  return { body: undefined, writeFlag: false, readFlag: false };
}

export const Bundle: MessageFns<Bundle> = {
  encode(
    message: Bundle,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.body !== undefined) {
      Par.encode(message.body, writer.uint32(10).fork()).join();
    }
    if (message.writeFlag !== false) {
      writer.uint32(16).bool(message.writeFlag);
    }
    if (message.readFlag !== false) {
      writer.uint32(24).bool(message.readFlag);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Bundle {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBundle();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.body = Par.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.writeFlag = reader.bool();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.readFlag = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Bundle {
    return {
      body: isSet(object.body) ? Par.fromJSON(object.body) : undefined,
      writeFlag: isSet(object.writeFlag)
        ? globalThis.Boolean(object.writeFlag)
        : false,
      readFlag: isSet(object.readFlag)
        ? globalThis.Boolean(object.readFlag)
        : false,
    };
  },

  toJSON(message: Bundle): unknown {
    const obj: any = {};
    if (message.body !== undefined) {
      obj.body = Par.toJSON(message.body);
    }
    if (message.writeFlag !== false) {
      obj.writeFlag = message.writeFlag;
    }
    if (message.readFlag !== false) {
      obj.readFlag = message.readFlag;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Bundle>, I>>(base?: I): Bundle {
    return Bundle.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Bundle>, I>>(object: I): Bundle {
    const message = createBaseBundle();
    message.body =
      object.body !== undefined && object.body !== null
        ? Par.fromPartial(object.body)
        : undefined;
    message.writeFlag = object.writeFlag ?? false;
    message.readFlag = object.readFlag ?? false;
    return message;
  },
};

function createBaseSend(): Send {
  return {
    chan: undefined,
    data: [],
    persistent: false,
    locallyFree: new Uint8Array(0),
    connectiveUsed: false,
  };
}

export const Send: MessageFns<Send> = {
  encode(
    message: Send,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.chan !== undefined) {
      Par.encode(message.chan, writer.uint32(10).fork()).join();
    }
    for (const v of message.data) {
      Par.encode(v!, writer.uint32(18).fork()).join();
    }
    if (message.persistent !== false) {
      writer.uint32(24).bool(message.persistent);
    }
    if (message.locallyFree.length !== 0) {
      writer.uint32(42).bytes(message.locallyFree);
    }
    if (message.connectiveUsed !== false) {
      writer.uint32(48).bool(message.connectiveUsed);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Send {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSend();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.chan = Par.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.data.push(Par.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.persistent = reader.bool();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.locallyFree = reader.bytes();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.connectiveUsed = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Send {
    return {
      chan: isSet(object.chan) ? Par.fromJSON(object.chan) : undefined,
      data: globalThis.Array.isArray(object?.data)
        ? object.data.map((e: any) => Par.fromJSON(e))
        : [],
      persistent: isSet(object.persistent)
        ? globalThis.Boolean(object.persistent)
        : false,
      locallyFree: isSet(object.locallyFree)
        ? bytesFromBase64(object.locallyFree)
        : new Uint8Array(0),
      connectiveUsed: isSet(object.connectiveUsed)
        ? globalThis.Boolean(object.connectiveUsed)
        : false,
    };
  },

  toJSON(message: Send): unknown {
    const obj: any = {};
    if (message.chan !== undefined) {
      obj.chan = Par.toJSON(message.chan);
    }
    if (message.data?.length) {
      obj.data = message.data.map((e) => Par.toJSON(e));
    }
    if (message.persistent !== false) {
      obj.persistent = message.persistent;
    }
    if (message.locallyFree.length !== 0) {
      obj.locallyFree = base64FromBytes(message.locallyFree);
    }
    if (message.connectiveUsed !== false) {
      obj.connectiveUsed = message.connectiveUsed;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Send>, I>>(base?: I): Send {
    return Send.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Send>, I>>(object: I): Send {
    const message = createBaseSend();
    message.chan =
      object.chan !== undefined && object.chan !== null
        ? Par.fromPartial(object.chan)
        : undefined;
    message.data = object.data?.map((e) => Par.fromPartial(e)) || [];
    message.persistent = object.persistent ?? false;
    message.locallyFree = object.locallyFree ?? new Uint8Array(0);
    message.connectiveUsed = object.connectiveUsed ?? false;
    return message;
  },
};

function createBaseReceiveBind(): ReceiveBind {
  return {
    patterns: [],
    source: undefined,
    remainder: undefined,
    freeCount: 0,
  };
}

export const ReceiveBind: MessageFns<ReceiveBind> = {
  encode(
    message: ReceiveBind,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    for (const v of message.patterns) {
      Par.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.source !== undefined) {
      Par.encode(message.source, writer.uint32(18).fork()).join();
    }
    if (message.remainder !== undefined) {
      Var.encode(message.remainder, writer.uint32(26).fork()).join();
    }
    if (message.freeCount !== 0) {
      writer.uint32(32).int32(message.freeCount);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ReceiveBind {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseReceiveBind();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.patterns.push(Par.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.source = Par.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.remainder = Var.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.freeCount = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ReceiveBind {
    return {
      patterns: globalThis.Array.isArray(object?.patterns)
        ? object.patterns.map((e: any) => Par.fromJSON(e))
        : [],
      source: isSet(object.source) ? Par.fromJSON(object.source) : undefined,
      remainder: isSet(object.remainder)
        ? Var.fromJSON(object.remainder)
        : undefined,
      freeCount: isSet(object.freeCount)
        ? globalThis.Number(object.freeCount)
        : 0,
    };
  },

  toJSON(message: ReceiveBind): unknown {
    const obj: any = {};
    if (message.patterns?.length) {
      obj.patterns = message.patterns.map((e) => Par.toJSON(e));
    }
    if (message.source !== undefined) {
      obj.source = Par.toJSON(message.source);
    }
    if (message.remainder !== undefined) {
      obj.remainder = Var.toJSON(message.remainder);
    }
    if (message.freeCount !== 0) {
      obj.freeCount = Math.round(message.freeCount);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ReceiveBind>, I>>(base?: I): ReceiveBind {
    return ReceiveBind.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ReceiveBind>, I>>(
    object: I,
  ): ReceiveBind {
    const message = createBaseReceiveBind();
    message.patterns = object.patterns?.map((e) => Par.fromPartial(e)) || [];
    message.source =
      object.source !== undefined && object.source !== null
        ? Par.fromPartial(object.source)
        : undefined;
    message.remainder =
      object.remainder !== undefined && object.remainder !== null
        ? Var.fromPartial(object.remainder)
        : undefined;
    message.freeCount = object.freeCount ?? 0;
    return message;
  },
};

function createBaseBindPattern(): BindPattern {
  return { patterns: [], remainder: undefined, freeCount: 0 };
}

export const BindPattern: MessageFns<BindPattern> = {
  encode(
    message: BindPattern,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    for (const v of message.patterns) {
      Par.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.remainder !== undefined) {
      Var.encode(message.remainder, writer.uint32(18).fork()).join();
    }
    if (message.freeCount !== 0) {
      writer.uint32(24).int32(message.freeCount);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BindPattern {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBindPattern();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.patterns.push(Par.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.remainder = Var.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.freeCount = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BindPattern {
    return {
      patterns: globalThis.Array.isArray(object?.patterns)
        ? object.patterns.map((e: any) => Par.fromJSON(e))
        : [],
      remainder: isSet(object.remainder)
        ? Var.fromJSON(object.remainder)
        : undefined,
      freeCount: isSet(object.freeCount)
        ? globalThis.Number(object.freeCount)
        : 0,
    };
  },

  toJSON(message: BindPattern): unknown {
    const obj: any = {};
    if (message.patterns?.length) {
      obj.patterns = message.patterns.map((e) => Par.toJSON(e));
    }
    if (message.remainder !== undefined) {
      obj.remainder = Var.toJSON(message.remainder);
    }
    if (message.freeCount !== 0) {
      obj.freeCount = Math.round(message.freeCount);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<BindPattern>, I>>(base?: I): BindPattern {
    return BindPattern.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BindPattern>, I>>(
    object: I,
  ): BindPattern {
    const message = createBaseBindPattern();
    message.patterns = object.patterns?.map((e) => Par.fromPartial(e)) || [];
    message.remainder =
      object.remainder !== undefined && object.remainder !== null
        ? Var.fromPartial(object.remainder)
        : undefined;
    message.freeCount = object.freeCount ?? 0;
    return message;
  },
};

function createBaseListBindPatterns(): ListBindPatterns {
  return { patterns: [] };
}

export const ListBindPatterns: MessageFns<ListBindPatterns> = {
  encode(
    message: ListBindPatterns,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    for (const v of message.patterns) {
      BindPattern.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListBindPatterns {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListBindPatterns();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.patterns.push(BindPattern.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListBindPatterns {
    return {
      patterns: globalThis.Array.isArray(object?.patterns)
        ? object.patterns.map((e: any) => BindPattern.fromJSON(e))
        : [],
    };
  },

  toJSON(message: ListBindPatterns): unknown {
    const obj: any = {};
    if (message.patterns?.length) {
      obj.patterns = message.patterns.map((e) => BindPattern.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListBindPatterns>, I>>(
    base?: I,
  ): ListBindPatterns {
    return ListBindPatterns.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListBindPatterns>, I>>(
    object: I,
  ): ListBindPatterns {
    const message = createBaseListBindPatterns();
    message.patterns =
      object.patterns?.map((e) => BindPattern.fromPartial(e)) || [];
    return message;
  },
};

function createBaseReceive(): Receive {
  return {
    binds: [],
    body: undefined,
    persistent: false,
    peek: false,
    bindCount: 0,
    locallyFree: new Uint8Array(0),
    connectiveUsed: false,
  };
}

export const Receive: MessageFns<Receive> = {
  encode(
    message: Receive,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    for (const v of message.binds) {
      ReceiveBind.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.body !== undefined) {
      Par.encode(message.body, writer.uint32(18).fork()).join();
    }
    if (message.persistent !== false) {
      writer.uint32(24).bool(message.persistent);
    }
    if (message.peek !== false) {
      writer.uint32(32).bool(message.peek);
    }
    if (message.bindCount !== 0) {
      writer.uint32(40).int32(message.bindCount);
    }
    if (message.locallyFree.length !== 0) {
      writer.uint32(50).bytes(message.locallyFree);
    }
    if (message.connectiveUsed !== false) {
      writer.uint32(56).bool(message.connectiveUsed);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Receive {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseReceive();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.binds.push(ReceiveBind.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.body = Par.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.persistent = reader.bool();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.peek = reader.bool();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.bindCount = reader.int32();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.locallyFree = reader.bytes();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.connectiveUsed = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Receive {
    return {
      binds: globalThis.Array.isArray(object?.binds)
        ? object.binds.map((e: any) => ReceiveBind.fromJSON(e))
        : [],
      body: isSet(object.body) ? Par.fromJSON(object.body) : undefined,
      persistent: isSet(object.persistent)
        ? globalThis.Boolean(object.persistent)
        : false,
      peek: isSet(object.peek) ? globalThis.Boolean(object.peek) : false,
      bindCount: isSet(object.bindCount)
        ? globalThis.Number(object.bindCount)
        : 0,
      locallyFree: isSet(object.locallyFree)
        ? bytesFromBase64(object.locallyFree)
        : new Uint8Array(0),
      connectiveUsed: isSet(object.connectiveUsed)
        ? globalThis.Boolean(object.connectiveUsed)
        : false,
    };
  },

  toJSON(message: Receive): unknown {
    const obj: any = {};
    if (message.binds?.length) {
      obj.binds = message.binds.map((e) => ReceiveBind.toJSON(e));
    }
    if (message.body !== undefined) {
      obj.body = Par.toJSON(message.body);
    }
    if (message.persistent !== false) {
      obj.persistent = message.persistent;
    }
    if (message.peek !== false) {
      obj.peek = message.peek;
    }
    if (message.bindCount !== 0) {
      obj.bindCount = Math.round(message.bindCount);
    }
    if (message.locallyFree.length !== 0) {
      obj.locallyFree = base64FromBytes(message.locallyFree);
    }
    if (message.connectiveUsed !== false) {
      obj.connectiveUsed = message.connectiveUsed;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Receive>, I>>(base?: I): Receive {
    return Receive.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Receive>, I>>(object: I): Receive {
    const message = createBaseReceive();
    message.binds = object.binds?.map((e) => ReceiveBind.fromPartial(e)) || [];
    message.body =
      object.body !== undefined && object.body !== null
        ? Par.fromPartial(object.body)
        : undefined;
    message.persistent = object.persistent ?? false;
    message.peek = object.peek ?? false;
    message.bindCount = object.bindCount ?? 0;
    message.locallyFree = object.locallyFree ?? new Uint8Array(0);
    message.connectiveUsed = object.connectiveUsed ?? false;
    return message;
  },
};

function createBaseNew(): New {
  return {
    bindCount: 0,
    p: undefined,
    uri: [],
    injections: {},
    locallyFree: new Uint8Array(0),
  };
}

export const New: MessageFns<New> = {
  encode(
    message: New,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.bindCount !== 0) {
      writer.uint32(8).sint32(message.bindCount);
    }
    if (message.p !== undefined) {
      Par.encode(message.p, writer.uint32(18).fork()).join();
    }
    for (const v of message.uri) {
      writer.uint32(26).string(v!);
    }
    Object.entries(message.injections).forEach(([key, value]) => {
      New_InjectionsEntry.encode(
        { key: key as any, value },
        writer.uint32(34).fork(),
      ).join();
    });
    if (message.locallyFree.length !== 0) {
      writer.uint32(42).bytes(message.locallyFree);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): New {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNew();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.bindCount = reader.sint32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.p = Par.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.uri.push(reader.string());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          const entry4 = New_InjectionsEntry.decode(reader, reader.uint32());
          if (entry4.value !== undefined) {
            message.injections[entry4.key] = entry4.value;
          }
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.locallyFree = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): New {
    return {
      bindCount: isSet(object.bindCount)
        ? globalThis.Number(object.bindCount)
        : 0,
      p: isSet(object.p) ? Par.fromJSON(object.p) : undefined,
      uri: globalThis.Array.isArray(object?.uri)
        ? object.uri.map((e: any) => globalThis.String(e))
        : [],
      injections: isObject(object.injections)
        ? Object.entries(object.injections).reduce<{ [key: string]: Par }>(
            (acc, [key, value]) => {
              acc[key] = Par.fromJSON(value);
              return acc;
            },
            {},
          )
        : {},
      locallyFree: isSet(object.locallyFree)
        ? bytesFromBase64(object.locallyFree)
        : new Uint8Array(0),
    };
  },

  toJSON(message: New): unknown {
    const obj: any = {};
    if (message.bindCount !== 0) {
      obj.bindCount = Math.round(message.bindCount);
    }
    if (message.p !== undefined) {
      obj.p = Par.toJSON(message.p);
    }
    if (message.uri?.length) {
      obj.uri = message.uri;
    }
    if (message.injections) {
      const entries = Object.entries(message.injections);
      if (entries.length > 0) {
        obj.injections = {};
        entries.forEach(([k, v]) => {
          obj.injections[k] = Par.toJSON(v);
        });
      }
    }
    if (message.locallyFree.length !== 0) {
      obj.locallyFree = base64FromBytes(message.locallyFree);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<New>, I>>(base?: I): New {
    return New.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<New>, I>>(object: I): New {
    const message = createBaseNew();
    message.bindCount = object.bindCount ?? 0;
    message.p =
      object.p !== undefined && object.p !== null
        ? Par.fromPartial(object.p)
        : undefined;
    message.uri = object.uri?.map((e) => e) || [];
    message.injections = Object.entries(object.injections ?? {}).reduce<{
      [key: string]: Par;
    }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = Par.fromPartial(value);
      }
      return acc;
    }, {});
    message.locallyFree = object.locallyFree ?? new Uint8Array(0);
    return message;
  },
};

function createBaseNew_InjectionsEntry(): New_InjectionsEntry {
  return { key: "", value: undefined };
}

export const New_InjectionsEntry: MessageFns<New_InjectionsEntry> = {
  encode(
    message: New_InjectionsEntry,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      Par.encode(message.value, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): New_InjectionsEntry {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNew_InjectionsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = Par.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): New_InjectionsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? Par.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: New_InjectionsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = Par.toJSON(message.value);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<New_InjectionsEntry>, I>>(
    base?: I,
  ): New_InjectionsEntry {
    return New_InjectionsEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<New_InjectionsEntry>, I>>(
    object: I,
  ): New_InjectionsEntry {
    const message = createBaseNew_InjectionsEntry();
    message.key = object.key ?? "";
    message.value =
      object.value !== undefined && object.value !== null
        ? Par.fromPartial(object.value)
        : undefined;
    return message;
  },
};

function createBaseMatchCase(): MatchCase {
  return { pattern: undefined, source: undefined, freeCount: 0 };
}

export const MatchCase: MessageFns<MatchCase> = {
  encode(
    message: MatchCase,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.pattern !== undefined) {
      Par.encode(message.pattern, writer.uint32(10).fork()).join();
    }
    if (message.source !== undefined) {
      Par.encode(message.source, writer.uint32(18).fork()).join();
    }
    if (message.freeCount !== 0) {
      writer.uint32(24).int32(message.freeCount);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MatchCase {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMatchCase();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.pattern = Par.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.source = Par.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.freeCount = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MatchCase {
    return {
      pattern: isSet(object.pattern) ? Par.fromJSON(object.pattern) : undefined,
      source: isSet(object.source) ? Par.fromJSON(object.source) : undefined,
      freeCount: isSet(object.freeCount)
        ? globalThis.Number(object.freeCount)
        : 0,
    };
  },

  toJSON(message: MatchCase): unknown {
    const obj: any = {};
    if (message.pattern !== undefined) {
      obj.pattern = Par.toJSON(message.pattern);
    }
    if (message.source !== undefined) {
      obj.source = Par.toJSON(message.source);
    }
    if (message.freeCount !== 0) {
      obj.freeCount = Math.round(message.freeCount);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MatchCase>, I>>(base?: I): MatchCase {
    return MatchCase.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MatchCase>, I>>(
    object: I,
  ): MatchCase {
    const message = createBaseMatchCase();
    message.pattern =
      object.pattern !== undefined && object.pattern !== null
        ? Par.fromPartial(object.pattern)
        : undefined;
    message.source =
      object.source !== undefined && object.source !== null
        ? Par.fromPartial(object.source)
        : undefined;
    message.freeCount = object.freeCount ?? 0;
    return message;
  },
};

function createBaseMatch(): Match {
  return {
    target: undefined,
    cases: [],
    locallyFree: new Uint8Array(0),
    connectiveUsed: false,
  };
}

export const Match: MessageFns<Match> = {
  encode(
    message: Match,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.target !== undefined) {
      Par.encode(message.target, writer.uint32(10).fork()).join();
    }
    for (const v of message.cases) {
      MatchCase.encode(v!, writer.uint32(18).fork()).join();
    }
    if (message.locallyFree.length !== 0) {
      writer.uint32(34).bytes(message.locallyFree);
    }
    if (message.connectiveUsed !== false) {
      writer.uint32(40).bool(message.connectiveUsed);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Match {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMatch();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.target = Par.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.cases.push(MatchCase.decode(reader, reader.uint32()));
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.locallyFree = reader.bytes();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.connectiveUsed = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Match {
    return {
      target: isSet(object.target) ? Par.fromJSON(object.target) : undefined,
      cases: globalThis.Array.isArray(object?.cases)
        ? object.cases.map((e: any) => MatchCase.fromJSON(e))
        : [],
      locallyFree: isSet(object.locallyFree)
        ? bytesFromBase64(object.locallyFree)
        : new Uint8Array(0),
      connectiveUsed: isSet(object.connectiveUsed)
        ? globalThis.Boolean(object.connectiveUsed)
        : false,
    };
  },

  toJSON(message: Match): unknown {
    const obj: any = {};
    if (message.target !== undefined) {
      obj.target = Par.toJSON(message.target);
    }
    if (message.cases?.length) {
      obj.cases = message.cases.map((e) => MatchCase.toJSON(e));
    }
    if (message.locallyFree.length !== 0) {
      obj.locallyFree = base64FromBytes(message.locallyFree);
    }
    if (message.connectiveUsed !== false) {
      obj.connectiveUsed = message.connectiveUsed;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Match>, I>>(base?: I): Match {
    return Match.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Match>, I>>(object: I): Match {
    const message = createBaseMatch();
    message.target =
      object.target !== undefined && object.target !== null
        ? Par.fromPartial(object.target)
        : undefined;
    message.cases = object.cases?.map((e) => MatchCase.fromPartial(e)) || [];
    message.locallyFree = object.locallyFree ?? new Uint8Array(0);
    message.connectiveUsed = object.connectiveUsed ?? false;
    return message;
  },
};

function createBaseExpr(): Expr {
  return {
    gBool: undefined,
    gInt: undefined,
    gString: undefined,
    gUri: undefined,
    gByteArray: undefined,
    eNotBody: undefined,
    eNegBody: undefined,
    eMultBody: undefined,
    eDivBody: undefined,
    ePlusBody: undefined,
    eMinusBody: undefined,
    eLtBody: undefined,
    eLteBody: undefined,
    eGtBody: undefined,
    eGteBody: undefined,
    eEqBody: undefined,
    eNeqBody: undefined,
    eAndBody: undefined,
    eOrBody: undefined,
    eVarBody: undefined,
    eListBody: undefined,
    eTupleBody: undefined,
    eSetBody: undefined,
    eMapBody: undefined,
    eMethodBody: undefined,
    eMatchesBody: undefined,
    ePercentPercentBody: undefined,
    ePlusPlusBody: undefined,
    eMinusMinusBody: undefined,
    eModBody: undefined,
  };
}

export const Expr: MessageFns<Expr> = {
  encode(
    message: Expr,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.gBool !== undefined) {
      writer.uint32(8).bool(message.gBool);
    }
    if (message.gInt !== undefined) {
      writer.uint32(16).sint64(message.gInt);
    }
    if (message.gString !== undefined) {
      writer.uint32(26).string(message.gString);
    }
    if (message.gUri !== undefined) {
      writer.uint32(34).string(message.gUri);
    }
    if (message.gByteArray !== undefined) {
      writer.uint32(202).bytes(message.gByteArray);
    }
    if (message.eNotBody !== undefined) {
      ENot.encode(message.eNotBody, writer.uint32(42).fork()).join();
    }
    if (message.eNegBody !== undefined) {
      ENeg.encode(message.eNegBody, writer.uint32(50).fork()).join();
    }
    if (message.eMultBody !== undefined) {
      EMult.encode(message.eMultBody, writer.uint32(58).fork()).join();
    }
    if (message.eDivBody !== undefined) {
      EDiv.encode(message.eDivBody, writer.uint32(66).fork()).join();
    }
    if (message.ePlusBody !== undefined) {
      EPlus.encode(message.ePlusBody, writer.uint32(74).fork()).join();
    }
    if (message.eMinusBody !== undefined) {
      EMinus.encode(message.eMinusBody, writer.uint32(82).fork()).join();
    }
    if (message.eLtBody !== undefined) {
      ELt.encode(message.eLtBody, writer.uint32(90).fork()).join();
    }
    if (message.eLteBody !== undefined) {
      ELte.encode(message.eLteBody, writer.uint32(98).fork()).join();
    }
    if (message.eGtBody !== undefined) {
      EGt.encode(message.eGtBody, writer.uint32(106).fork()).join();
    }
    if (message.eGteBody !== undefined) {
      EGte.encode(message.eGteBody, writer.uint32(114).fork()).join();
    }
    if (message.eEqBody !== undefined) {
      EEq.encode(message.eEqBody, writer.uint32(122).fork()).join();
    }
    if (message.eNeqBody !== undefined) {
      ENeq.encode(message.eNeqBody, writer.uint32(130).fork()).join();
    }
    if (message.eAndBody !== undefined) {
      EAnd.encode(message.eAndBody, writer.uint32(138).fork()).join();
    }
    if (message.eOrBody !== undefined) {
      EOr.encode(message.eOrBody, writer.uint32(146).fork()).join();
    }
    if (message.eVarBody !== undefined) {
      EVar.encode(message.eVarBody, writer.uint32(154).fork()).join();
    }
    if (message.eListBody !== undefined) {
      EList.encode(message.eListBody, writer.uint32(162).fork()).join();
    }
    if (message.eTupleBody !== undefined) {
      ETuple.encode(message.eTupleBody, writer.uint32(170).fork()).join();
    }
    if (message.eSetBody !== undefined) {
      ESet.encode(message.eSetBody, writer.uint32(178).fork()).join();
    }
    if (message.eMapBody !== undefined) {
      EMap.encode(message.eMapBody, writer.uint32(186).fork()).join();
    }
    if (message.eMethodBody !== undefined) {
      EMethod.encode(message.eMethodBody, writer.uint32(194).fork()).join();
    }
    if (message.eMatchesBody !== undefined) {
      EMatches.encode(message.eMatchesBody, writer.uint32(218).fork()).join();
    }
    if (message.ePercentPercentBody !== undefined) {
      EPercentPercent.encode(
        message.ePercentPercentBody,
        writer.uint32(226).fork(),
      ).join();
    }
    if (message.ePlusPlusBody !== undefined) {
      EPlusPlus.encode(message.ePlusPlusBody, writer.uint32(234).fork()).join();
    }
    if (message.eMinusMinusBody !== undefined) {
      EMinusMinus.encode(
        message.eMinusMinusBody,
        writer.uint32(242).fork(),
      ).join();
    }
    if (message.eModBody !== undefined) {
      EMod.encode(message.eModBody, writer.uint32(250).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Expr {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseExpr();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.gBool = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.gInt = longToNumber(reader.sint64());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.gString = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.gUri = reader.string();
          continue;
        }
        case 25: {
          if (tag !== 202) {
            break;
          }

          message.gByteArray = reader.bytes();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.eNotBody = ENot.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.eNegBody = ENeg.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.eMultBody = EMult.decode(reader, reader.uint32());
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.eDivBody = EDiv.decode(reader, reader.uint32());
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.ePlusBody = EPlus.decode(reader, reader.uint32());
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.eMinusBody = EMinus.decode(reader, reader.uint32());
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.eLtBody = ELt.decode(reader, reader.uint32());
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.eLteBody = ELte.decode(reader, reader.uint32());
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.eGtBody = EGt.decode(reader, reader.uint32());
          continue;
        }
        case 14: {
          if (tag !== 114) {
            break;
          }

          message.eGteBody = EGte.decode(reader, reader.uint32());
          continue;
        }
        case 15: {
          if (tag !== 122) {
            break;
          }

          message.eEqBody = EEq.decode(reader, reader.uint32());
          continue;
        }
        case 16: {
          if (tag !== 130) {
            break;
          }

          message.eNeqBody = ENeq.decode(reader, reader.uint32());
          continue;
        }
        case 17: {
          if (tag !== 138) {
            break;
          }

          message.eAndBody = EAnd.decode(reader, reader.uint32());
          continue;
        }
        case 18: {
          if (tag !== 146) {
            break;
          }

          message.eOrBody = EOr.decode(reader, reader.uint32());
          continue;
        }
        case 19: {
          if (tag !== 154) {
            break;
          }

          message.eVarBody = EVar.decode(reader, reader.uint32());
          continue;
        }
        case 20: {
          if (tag !== 162) {
            break;
          }

          message.eListBody = EList.decode(reader, reader.uint32());
          continue;
        }
        case 21: {
          if (tag !== 170) {
            break;
          }

          message.eTupleBody = ETuple.decode(reader, reader.uint32());
          continue;
        }
        case 22: {
          if (tag !== 178) {
            break;
          }

          message.eSetBody = ESet.decode(reader, reader.uint32());
          continue;
        }
        case 23: {
          if (tag !== 186) {
            break;
          }

          message.eMapBody = EMap.decode(reader, reader.uint32());
          continue;
        }
        case 24: {
          if (tag !== 194) {
            break;
          }

          message.eMethodBody = EMethod.decode(reader, reader.uint32());
          continue;
        }
        case 27: {
          if (tag !== 218) {
            break;
          }

          message.eMatchesBody = EMatches.decode(reader, reader.uint32());
          continue;
        }
        case 28: {
          if (tag !== 226) {
            break;
          }

          message.ePercentPercentBody = EPercentPercent.decode(
            reader,
            reader.uint32(),
          );
          continue;
        }
        case 29: {
          if (tag !== 234) {
            break;
          }

          message.ePlusPlusBody = EPlusPlus.decode(reader, reader.uint32());
          continue;
        }
        case 30: {
          if (tag !== 242) {
            break;
          }

          message.eMinusMinusBody = EMinusMinus.decode(reader, reader.uint32());
          continue;
        }
        case 31: {
          if (tag !== 250) {
            break;
          }

          message.eModBody = EMod.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Expr {
    return {
      gBool: isSet(object.gBool) ? globalThis.Boolean(object.gBool) : undefined,
      gInt: isSet(object.gInt) ? globalThis.Number(object.gInt) : undefined,
      gString: isSet(object.gString)
        ? globalThis.String(object.gString)
        : undefined,
      gUri: isSet(object.gUri) ? globalThis.String(object.gUri) : undefined,
      gByteArray: isSet(object.gByteArray)
        ? bytesFromBase64(object.gByteArray)
        : undefined,
      eNotBody: isSet(object.eNotBody)
        ? ENot.fromJSON(object.eNotBody)
        : undefined,
      eNegBody: isSet(object.eNegBody)
        ? ENeg.fromJSON(object.eNegBody)
        : undefined,
      eMultBody: isSet(object.eMultBody)
        ? EMult.fromJSON(object.eMultBody)
        : undefined,
      eDivBody: isSet(object.eDivBody)
        ? EDiv.fromJSON(object.eDivBody)
        : undefined,
      ePlusBody: isSet(object.ePlusBody)
        ? EPlus.fromJSON(object.ePlusBody)
        : undefined,
      eMinusBody: isSet(object.eMinusBody)
        ? EMinus.fromJSON(object.eMinusBody)
        : undefined,
      eLtBody: isSet(object.eLtBody) ? ELt.fromJSON(object.eLtBody) : undefined,
      eLteBody: isSet(object.eLteBody)
        ? ELte.fromJSON(object.eLteBody)
        : undefined,
      eGtBody: isSet(object.eGtBody) ? EGt.fromJSON(object.eGtBody) : undefined,
      eGteBody: isSet(object.eGteBody)
        ? EGte.fromJSON(object.eGteBody)
        : undefined,
      eEqBody: isSet(object.eEqBody) ? EEq.fromJSON(object.eEqBody) : undefined,
      eNeqBody: isSet(object.eNeqBody)
        ? ENeq.fromJSON(object.eNeqBody)
        : undefined,
      eAndBody: isSet(object.eAndBody)
        ? EAnd.fromJSON(object.eAndBody)
        : undefined,
      eOrBody: isSet(object.eOrBody) ? EOr.fromJSON(object.eOrBody) : undefined,
      eVarBody: isSet(object.eVarBody)
        ? EVar.fromJSON(object.eVarBody)
        : undefined,
      eListBody: isSet(object.eListBody)
        ? EList.fromJSON(object.eListBody)
        : undefined,
      eTupleBody: isSet(object.eTupleBody)
        ? ETuple.fromJSON(object.eTupleBody)
        : undefined,
      eSetBody: isSet(object.eSetBody)
        ? ESet.fromJSON(object.eSetBody)
        : undefined,
      eMapBody: isSet(object.eMapBody)
        ? EMap.fromJSON(object.eMapBody)
        : undefined,
      eMethodBody: isSet(object.eMethodBody)
        ? EMethod.fromJSON(object.eMethodBody)
        : undefined,
      eMatchesBody: isSet(object.eMatchesBody)
        ? EMatches.fromJSON(object.eMatchesBody)
        : undefined,
      ePercentPercentBody: isSet(object.ePercentPercentBody)
        ? EPercentPercent.fromJSON(object.ePercentPercentBody)
        : undefined,
      ePlusPlusBody: isSet(object.ePlusPlusBody)
        ? EPlusPlus.fromJSON(object.ePlusPlusBody)
        : undefined,
      eMinusMinusBody: isSet(object.eMinusMinusBody)
        ? EMinusMinus.fromJSON(object.eMinusMinusBody)
        : undefined,
      eModBody: isSet(object.eModBody)
        ? EMod.fromJSON(object.eModBody)
        : undefined,
    };
  },

  toJSON(message: Expr): unknown {
    const obj: any = {};
    if (message.gBool !== undefined) {
      obj.gBool = message.gBool;
    }
    if (message.gInt !== undefined) {
      obj.gInt = Math.round(message.gInt);
    }
    if (message.gString !== undefined) {
      obj.gString = message.gString;
    }
    if (message.gUri !== undefined) {
      obj.gUri = message.gUri;
    }
    if (message.gByteArray !== undefined) {
      obj.gByteArray = base64FromBytes(message.gByteArray);
    }
    if (message.eNotBody !== undefined) {
      obj.eNotBody = ENot.toJSON(message.eNotBody);
    }
    if (message.eNegBody !== undefined) {
      obj.eNegBody = ENeg.toJSON(message.eNegBody);
    }
    if (message.eMultBody !== undefined) {
      obj.eMultBody = EMult.toJSON(message.eMultBody);
    }
    if (message.eDivBody !== undefined) {
      obj.eDivBody = EDiv.toJSON(message.eDivBody);
    }
    if (message.ePlusBody !== undefined) {
      obj.ePlusBody = EPlus.toJSON(message.ePlusBody);
    }
    if (message.eMinusBody !== undefined) {
      obj.eMinusBody = EMinus.toJSON(message.eMinusBody);
    }
    if (message.eLtBody !== undefined) {
      obj.eLtBody = ELt.toJSON(message.eLtBody);
    }
    if (message.eLteBody !== undefined) {
      obj.eLteBody = ELte.toJSON(message.eLteBody);
    }
    if (message.eGtBody !== undefined) {
      obj.eGtBody = EGt.toJSON(message.eGtBody);
    }
    if (message.eGteBody !== undefined) {
      obj.eGteBody = EGte.toJSON(message.eGteBody);
    }
    if (message.eEqBody !== undefined) {
      obj.eEqBody = EEq.toJSON(message.eEqBody);
    }
    if (message.eNeqBody !== undefined) {
      obj.eNeqBody = ENeq.toJSON(message.eNeqBody);
    }
    if (message.eAndBody !== undefined) {
      obj.eAndBody = EAnd.toJSON(message.eAndBody);
    }
    if (message.eOrBody !== undefined) {
      obj.eOrBody = EOr.toJSON(message.eOrBody);
    }
    if (message.eVarBody !== undefined) {
      obj.eVarBody = EVar.toJSON(message.eVarBody);
    }
    if (message.eListBody !== undefined) {
      obj.eListBody = EList.toJSON(message.eListBody);
    }
    if (message.eTupleBody !== undefined) {
      obj.eTupleBody = ETuple.toJSON(message.eTupleBody);
    }
    if (message.eSetBody !== undefined) {
      obj.eSetBody = ESet.toJSON(message.eSetBody);
    }
    if (message.eMapBody !== undefined) {
      obj.eMapBody = EMap.toJSON(message.eMapBody);
    }
    if (message.eMethodBody !== undefined) {
      obj.eMethodBody = EMethod.toJSON(message.eMethodBody);
    }
    if (message.eMatchesBody !== undefined) {
      obj.eMatchesBody = EMatches.toJSON(message.eMatchesBody);
    }
    if (message.ePercentPercentBody !== undefined) {
      obj.ePercentPercentBody = EPercentPercent.toJSON(
        message.ePercentPercentBody,
      );
    }
    if (message.ePlusPlusBody !== undefined) {
      obj.ePlusPlusBody = EPlusPlus.toJSON(message.ePlusPlusBody);
    }
    if (message.eMinusMinusBody !== undefined) {
      obj.eMinusMinusBody = EMinusMinus.toJSON(message.eMinusMinusBody);
    }
    if (message.eModBody !== undefined) {
      obj.eModBody = EMod.toJSON(message.eModBody);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Expr>, I>>(base?: I): Expr {
    return Expr.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Expr>, I>>(object: I): Expr {
    const message = createBaseExpr();
    message.gBool = object.gBool ?? undefined;
    message.gInt = object.gInt ?? undefined;
    message.gString = object.gString ?? undefined;
    message.gUri = object.gUri ?? undefined;
    message.gByteArray = object.gByteArray ?? undefined;
    message.eNotBody =
      object.eNotBody !== undefined && object.eNotBody !== null
        ? ENot.fromPartial(object.eNotBody)
        : undefined;
    message.eNegBody =
      object.eNegBody !== undefined && object.eNegBody !== null
        ? ENeg.fromPartial(object.eNegBody)
        : undefined;
    message.eMultBody =
      object.eMultBody !== undefined && object.eMultBody !== null
        ? EMult.fromPartial(object.eMultBody)
        : undefined;
    message.eDivBody =
      object.eDivBody !== undefined && object.eDivBody !== null
        ? EDiv.fromPartial(object.eDivBody)
        : undefined;
    message.ePlusBody =
      object.ePlusBody !== undefined && object.ePlusBody !== null
        ? EPlus.fromPartial(object.ePlusBody)
        : undefined;
    message.eMinusBody =
      object.eMinusBody !== undefined && object.eMinusBody !== null
        ? EMinus.fromPartial(object.eMinusBody)
        : undefined;
    message.eLtBody =
      object.eLtBody !== undefined && object.eLtBody !== null
        ? ELt.fromPartial(object.eLtBody)
        : undefined;
    message.eLteBody =
      object.eLteBody !== undefined && object.eLteBody !== null
        ? ELte.fromPartial(object.eLteBody)
        : undefined;
    message.eGtBody =
      object.eGtBody !== undefined && object.eGtBody !== null
        ? EGt.fromPartial(object.eGtBody)
        : undefined;
    message.eGteBody =
      object.eGteBody !== undefined && object.eGteBody !== null
        ? EGte.fromPartial(object.eGteBody)
        : undefined;
    message.eEqBody =
      object.eEqBody !== undefined && object.eEqBody !== null
        ? EEq.fromPartial(object.eEqBody)
        : undefined;
    message.eNeqBody =
      object.eNeqBody !== undefined && object.eNeqBody !== null
        ? ENeq.fromPartial(object.eNeqBody)
        : undefined;
    message.eAndBody =
      object.eAndBody !== undefined && object.eAndBody !== null
        ? EAnd.fromPartial(object.eAndBody)
        : undefined;
    message.eOrBody =
      object.eOrBody !== undefined && object.eOrBody !== null
        ? EOr.fromPartial(object.eOrBody)
        : undefined;
    message.eVarBody =
      object.eVarBody !== undefined && object.eVarBody !== null
        ? EVar.fromPartial(object.eVarBody)
        : undefined;
    message.eListBody =
      object.eListBody !== undefined && object.eListBody !== null
        ? EList.fromPartial(object.eListBody)
        : undefined;
    message.eTupleBody =
      object.eTupleBody !== undefined && object.eTupleBody !== null
        ? ETuple.fromPartial(object.eTupleBody)
        : undefined;
    message.eSetBody =
      object.eSetBody !== undefined && object.eSetBody !== null
        ? ESet.fromPartial(object.eSetBody)
        : undefined;
    message.eMapBody =
      object.eMapBody !== undefined && object.eMapBody !== null
        ? EMap.fromPartial(object.eMapBody)
        : undefined;
    message.eMethodBody =
      object.eMethodBody !== undefined && object.eMethodBody !== null
        ? EMethod.fromPartial(object.eMethodBody)
        : undefined;
    message.eMatchesBody =
      object.eMatchesBody !== undefined && object.eMatchesBody !== null
        ? EMatches.fromPartial(object.eMatchesBody)
        : undefined;
    message.ePercentPercentBody =
      object.ePercentPercentBody !== undefined &&
      object.ePercentPercentBody !== null
        ? EPercentPercent.fromPartial(object.ePercentPercentBody)
        : undefined;
    message.ePlusPlusBody =
      object.ePlusPlusBody !== undefined && object.ePlusPlusBody !== null
        ? EPlusPlus.fromPartial(object.ePlusPlusBody)
        : undefined;
    message.eMinusMinusBody =
      object.eMinusMinusBody !== undefined && object.eMinusMinusBody !== null
        ? EMinusMinus.fromPartial(object.eMinusMinusBody)
        : undefined;
    message.eModBody =
      object.eModBody !== undefined && object.eModBody !== null
        ? EMod.fromPartial(object.eModBody)
        : undefined;
    return message;
  },
};

function createBaseEList(): EList {
  return {
    ps: [],
    locallyFree: new Uint8Array(0),
    connectiveUsed: false,
    remainder: undefined,
  };
}

export const EList: MessageFns<EList> = {
  encode(
    message: EList,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    for (const v of message.ps) {
      Par.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.locallyFree.length !== 0) {
      writer.uint32(26).bytes(message.locallyFree);
    }
    if (message.connectiveUsed !== false) {
      writer.uint32(32).bool(message.connectiveUsed);
    }
    if (message.remainder !== undefined) {
      Var.encode(message.remainder, writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EList {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEList();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.ps.push(Par.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.locallyFree = reader.bytes();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.connectiveUsed = reader.bool();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.remainder = Var.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EList {
    return {
      ps: globalThis.Array.isArray(object?.ps)
        ? object.ps.map((e: any) => Par.fromJSON(e))
        : [],
      locallyFree: isSet(object.locallyFree)
        ? bytesFromBase64(object.locallyFree)
        : new Uint8Array(0),
      connectiveUsed: isSet(object.connectiveUsed)
        ? globalThis.Boolean(object.connectiveUsed)
        : false,
      remainder: isSet(object.remainder)
        ? Var.fromJSON(object.remainder)
        : undefined,
    };
  },

  toJSON(message: EList): unknown {
    const obj: any = {};
    if (message.ps?.length) {
      obj.ps = message.ps.map((e) => Par.toJSON(e));
    }
    if (message.locallyFree.length !== 0) {
      obj.locallyFree = base64FromBytes(message.locallyFree);
    }
    if (message.connectiveUsed !== false) {
      obj.connectiveUsed = message.connectiveUsed;
    }
    if (message.remainder !== undefined) {
      obj.remainder = Var.toJSON(message.remainder);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<EList>, I>>(base?: I): EList {
    return EList.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<EList>, I>>(object: I): EList {
    const message = createBaseEList();
    message.ps = object.ps?.map((e) => Par.fromPartial(e)) || [];
    message.locallyFree = object.locallyFree ?? new Uint8Array(0);
    message.connectiveUsed = object.connectiveUsed ?? false;
    message.remainder =
      object.remainder !== undefined && object.remainder !== null
        ? Var.fromPartial(object.remainder)
        : undefined;
    return message;
  },
};

function createBaseETuple(): ETuple {
  return { ps: [], locallyFree: new Uint8Array(0), connectiveUsed: false };
}

export const ETuple: MessageFns<ETuple> = {
  encode(
    message: ETuple,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    for (const v of message.ps) {
      Par.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.locallyFree.length !== 0) {
      writer.uint32(26).bytes(message.locallyFree);
    }
    if (message.connectiveUsed !== false) {
      writer.uint32(32).bool(message.connectiveUsed);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ETuple {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseETuple();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.ps.push(Par.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.locallyFree = reader.bytes();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.connectiveUsed = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ETuple {
    return {
      ps: globalThis.Array.isArray(object?.ps)
        ? object.ps.map((e: any) => Par.fromJSON(e))
        : [],
      locallyFree: isSet(object.locallyFree)
        ? bytesFromBase64(object.locallyFree)
        : new Uint8Array(0),
      connectiveUsed: isSet(object.connectiveUsed)
        ? globalThis.Boolean(object.connectiveUsed)
        : false,
    };
  },

  toJSON(message: ETuple): unknown {
    const obj: any = {};
    if (message.ps?.length) {
      obj.ps = message.ps.map((e) => Par.toJSON(e));
    }
    if (message.locallyFree.length !== 0) {
      obj.locallyFree = base64FromBytes(message.locallyFree);
    }
    if (message.connectiveUsed !== false) {
      obj.connectiveUsed = message.connectiveUsed;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ETuple>, I>>(base?: I): ETuple {
    return ETuple.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ETuple>, I>>(object: I): ETuple {
    const message = createBaseETuple();
    message.ps = object.ps?.map((e) => Par.fromPartial(e)) || [];
    message.locallyFree = object.locallyFree ?? new Uint8Array(0);
    message.connectiveUsed = object.connectiveUsed ?? false;
    return message;
  },
};

function createBaseESet(): ESet {
  return {
    ps: [],
    locallyFree: new Uint8Array(0),
    connectiveUsed: false,
    remainder: undefined,
  };
}

export const ESet: MessageFns<ESet> = {
  encode(
    message: ESet,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    for (const v of message.ps) {
      Par.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.locallyFree.length !== 0) {
      writer.uint32(26).bytes(message.locallyFree);
    }
    if (message.connectiveUsed !== false) {
      writer.uint32(32).bool(message.connectiveUsed);
    }
    if (message.remainder !== undefined) {
      Var.encode(message.remainder, writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ESet {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseESet();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.ps.push(Par.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.locallyFree = reader.bytes();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.connectiveUsed = reader.bool();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.remainder = Var.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ESet {
    return {
      ps: globalThis.Array.isArray(object?.ps)
        ? object.ps.map((e: any) => Par.fromJSON(e))
        : [],
      locallyFree: isSet(object.locallyFree)
        ? bytesFromBase64(object.locallyFree)
        : new Uint8Array(0),
      connectiveUsed: isSet(object.connectiveUsed)
        ? globalThis.Boolean(object.connectiveUsed)
        : false,
      remainder: isSet(object.remainder)
        ? Var.fromJSON(object.remainder)
        : undefined,
    };
  },

  toJSON(message: ESet): unknown {
    const obj: any = {};
    if (message.ps?.length) {
      obj.ps = message.ps.map((e) => Par.toJSON(e));
    }
    if (message.locallyFree.length !== 0) {
      obj.locallyFree = base64FromBytes(message.locallyFree);
    }
    if (message.connectiveUsed !== false) {
      obj.connectiveUsed = message.connectiveUsed;
    }
    if (message.remainder !== undefined) {
      obj.remainder = Var.toJSON(message.remainder);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ESet>, I>>(base?: I): ESet {
    return ESet.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ESet>, I>>(object: I): ESet {
    const message = createBaseESet();
    message.ps = object.ps?.map((e) => Par.fromPartial(e)) || [];
    message.locallyFree = object.locallyFree ?? new Uint8Array(0);
    message.connectiveUsed = object.connectiveUsed ?? false;
    message.remainder =
      object.remainder !== undefined && object.remainder !== null
        ? Var.fromPartial(object.remainder)
        : undefined;
    return message;
  },
};

function createBaseEMap(): EMap {
  return {
    kvs: [],
    locallyFree: new Uint8Array(0),
    connectiveUsed: false,
    remainder: undefined,
  };
}

export const EMap: MessageFns<EMap> = {
  encode(
    message: EMap,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    for (const v of message.kvs) {
      KeyValuePair.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.locallyFree.length !== 0) {
      writer.uint32(26).bytes(message.locallyFree);
    }
    if (message.connectiveUsed !== false) {
      writer.uint32(32).bool(message.connectiveUsed);
    }
    if (message.remainder !== undefined) {
      Var.encode(message.remainder, writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EMap {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEMap();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.kvs.push(KeyValuePair.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.locallyFree = reader.bytes();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.connectiveUsed = reader.bool();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.remainder = Var.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EMap {
    return {
      kvs: globalThis.Array.isArray(object?.kvs)
        ? object.kvs.map((e: any) => KeyValuePair.fromJSON(e))
        : [],
      locallyFree: isSet(object.locallyFree)
        ? bytesFromBase64(object.locallyFree)
        : new Uint8Array(0),
      connectiveUsed: isSet(object.connectiveUsed)
        ? globalThis.Boolean(object.connectiveUsed)
        : false,
      remainder: isSet(object.remainder)
        ? Var.fromJSON(object.remainder)
        : undefined,
    };
  },

  toJSON(message: EMap): unknown {
    const obj: any = {};
    if (message.kvs?.length) {
      obj.kvs = message.kvs.map((e) => KeyValuePair.toJSON(e));
    }
    if (message.locallyFree.length !== 0) {
      obj.locallyFree = base64FromBytes(message.locallyFree);
    }
    if (message.connectiveUsed !== false) {
      obj.connectiveUsed = message.connectiveUsed;
    }
    if (message.remainder !== undefined) {
      obj.remainder = Var.toJSON(message.remainder);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<EMap>, I>>(base?: I): EMap {
    return EMap.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<EMap>, I>>(object: I): EMap {
    const message = createBaseEMap();
    message.kvs = object.kvs?.map((e) => KeyValuePair.fromPartial(e)) || [];
    message.locallyFree = object.locallyFree ?? new Uint8Array(0);
    message.connectiveUsed = object.connectiveUsed ?? false;
    message.remainder =
      object.remainder !== undefined && object.remainder !== null
        ? Var.fromPartial(object.remainder)
        : undefined;
    return message;
  },
};

function createBaseEMethod(): EMethod {
  return {
    methodName: "",
    target: undefined,
    arguments: [],
    locallyFree: new Uint8Array(0),
    connectiveUsed: false,
  };
}

export const EMethod: MessageFns<EMethod> = {
  encode(
    message: EMethod,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.methodName !== "") {
      writer.uint32(10).string(message.methodName);
    }
    if (message.target !== undefined) {
      Par.encode(message.target, writer.uint32(18).fork()).join();
    }
    for (const v of message.arguments) {
      Par.encode(v!, writer.uint32(26).fork()).join();
    }
    if (message.locallyFree.length !== 0) {
      writer.uint32(42).bytes(message.locallyFree);
    }
    if (message.connectiveUsed !== false) {
      writer.uint32(48).bool(message.connectiveUsed);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EMethod {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEMethod();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.methodName = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.target = Par.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.arguments.push(Par.decode(reader, reader.uint32()));
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.locallyFree = reader.bytes();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.connectiveUsed = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EMethod {
    return {
      methodName: isSet(object.methodName)
        ? globalThis.String(object.methodName)
        : "",
      target: isSet(object.target) ? Par.fromJSON(object.target) : undefined,
      arguments: globalThis.Array.isArray(object?.arguments)
        ? object.arguments.map((e: any) => Par.fromJSON(e))
        : [],
      locallyFree: isSet(object.locallyFree)
        ? bytesFromBase64(object.locallyFree)
        : new Uint8Array(0),
      connectiveUsed: isSet(object.connectiveUsed)
        ? globalThis.Boolean(object.connectiveUsed)
        : false,
    };
  },

  toJSON(message: EMethod): unknown {
    const obj: any = {};
    if (message.methodName !== "") {
      obj.methodName = message.methodName;
    }
    if (message.target !== undefined) {
      obj.target = Par.toJSON(message.target);
    }
    if (message.arguments?.length) {
      obj.arguments = message.arguments.map((e) => Par.toJSON(e));
    }
    if (message.locallyFree.length !== 0) {
      obj.locallyFree = base64FromBytes(message.locallyFree);
    }
    if (message.connectiveUsed !== false) {
      obj.connectiveUsed = message.connectiveUsed;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<EMethod>, I>>(base?: I): EMethod {
    return EMethod.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<EMethod>, I>>(object: I): EMethod {
    const message = createBaseEMethod();
    message.methodName = object.methodName ?? "";
    message.target =
      object.target !== undefined && object.target !== null
        ? Par.fromPartial(object.target)
        : undefined;
    message.arguments = object.arguments?.map((e) => Par.fromPartial(e)) || [];
    message.locallyFree = object.locallyFree ?? new Uint8Array(0);
    message.connectiveUsed = object.connectiveUsed ?? false;
    return message;
  },
};

function createBaseKeyValuePair(): KeyValuePair {
  return { key: undefined, value: undefined };
}

export const KeyValuePair: MessageFns<KeyValuePair> = {
  encode(
    message: KeyValuePair,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.key !== undefined) {
      Par.encode(message.key, writer.uint32(10).fork()).join();
    }
    if (message.value !== undefined) {
      Par.encode(message.value, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): KeyValuePair {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseKeyValuePair();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = Par.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = Par.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): KeyValuePair {
    return {
      key: isSet(object.key) ? Par.fromJSON(object.key) : undefined,
      value: isSet(object.value) ? Par.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: KeyValuePair): unknown {
    const obj: any = {};
    if (message.key !== undefined) {
      obj.key = Par.toJSON(message.key);
    }
    if (message.value !== undefined) {
      obj.value = Par.toJSON(message.value);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<KeyValuePair>, I>>(
    base?: I,
  ): KeyValuePair {
    return KeyValuePair.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<KeyValuePair>, I>>(
    object: I,
  ): KeyValuePair {
    const message = createBaseKeyValuePair();
    message.key =
      object.key !== undefined && object.key !== null
        ? Par.fromPartial(object.key)
        : undefined;
    message.value =
      object.value !== undefined && object.value !== null
        ? Par.fromPartial(object.value)
        : undefined;
    return message;
  },
};

function createBaseEVar(): EVar {
  return { v: undefined };
}

export const EVar: MessageFns<EVar> = {
  encode(
    message: EVar,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.v !== undefined) {
      Var.encode(message.v, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EVar {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEVar();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.v = Var.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EVar {
    return { v: isSet(object.v) ? Var.fromJSON(object.v) : undefined };
  },

  toJSON(message: EVar): unknown {
    const obj: any = {};
    if (message.v !== undefined) {
      obj.v = Var.toJSON(message.v);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<EVar>, I>>(base?: I): EVar {
    return EVar.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<EVar>, I>>(object: I): EVar {
    const message = createBaseEVar();
    message.v =
      object.v !== undefined && object.v !== null
        ? Var.fromPartial(object.v)
        : undefined;
    return message;
  },
};

function createBaseENot(): ENot {
  return { p: undefined };
}

export const ENot: MessageFns<ENot> = {
  encode(
    message: ENot,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.p !== undefined) {
      Par.encode(message.p, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ENot {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseENot();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.p = Par.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ENot {
    return { p: isSet(object.p) ? Par.fromJSON(object.p) : undefined };
  },

  toJSON(message: ENot): unknown {
    const obj: any = {};
    if (message.p !== undefined) {
      obj.p = Par.toJSON(message.p);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ENot>, I>>(base?: I): ENot {
    return ENot.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ENot>, I>>(object: I): ENot {
    const message = createBaseENot();
    message.p =
      object.p !== undefined && object.p !== null
        ? Par.fromPartial(object.p)
        : undefined;
    return message;
  },
};

function createBaseENeg(): ENeg {
  return { p: undefined };
}

export const ENeg: MessageFns<ENeg> = {
  encode(
    message: ENeg,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.p !== undefined) {
      Par.encode(message.p, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ENeg {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseENeg();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.p = Par.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ENeg {
    return { p: isSet(object.p) ? Par.fromJSON(object.p) : undefined };
  },

  toJSON(message: ENeg): unknown {
    const obj: any = {};
    if (message.p !== undefined) {
      obj.p = Par.toJSON(message.p);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ENeg>, I>>(base?: I): ENeg {
    return ENeg.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ENeg>, I>>(object: I): ENeg {
    const message = createBaseENeg();
    message.p =
      object.p !== undefined && object.p !== null
        ? Par.fromPartial(object.p)
        : undefined;
    return message;
  },
};

function createBaseEMult(): EMult {
  return { p1: undefined, p2: undefined };
}

export const EMult: MessageFns<EMult> = {
  encode(
    message: EMult,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.p1 !== undefined) {
      Par.encode(message.p1, writer.uint32(10).fork()).join();
    }
    if (message.p2 !== undefined) {
      Par.encode(message.p2, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EMult {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEMult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.p1 = Par.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.p2 = Par.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EMult {
    return {
      p1: isSet(object.p1) ? Par.fromJSON(object.p1) : undefined,
      p2: isSet(object.p2) ? Par.fromJSON(object.p2) : undefined,
    };
  },

  toJSON(message: EMult): unknown {
    const obj: any = {};
    if (message.p1 !== undefined) {
      obj.p1 = Par.toJSON(message.p1);
    }
    if (message.p2 !== undefined) {
      obj.p2 = Par.toJSON(message.p2);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<EMult>, I>>(base?: I): EMult {
    return EMult.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<EMult>, I>>(object: I): EMult {
    const message = createBaseEMult();
    message.p1 =
      object.p1 !== undefined && object.p1 !== null
        ? Par.fromPartial(object.p1)
        : undefined;
    message.p2 =
      object.p2 !== undefined && object.p2 !== null
        ? Par.fromPartial(object.p2)
        : undefined;
    return message;
  },
};

function createBaseEDiv(): EDiv {
  return { p1: undefined, p2: undefined };
}

export const EDiv: MessageFns<EDiv> = {
  encode(
    message: EDiv,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.p1 !== undefined) {
      Par.encode(message.p1, writer.uint32(10).fork()).join();
    }
    if (message.p2 !== undefined) {
      Par.encode(message.p2, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EDiv {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEDiv();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.p1 = Par.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.p2 = Par.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EDiv {
    return {
      p1: isSet(object.p1) ? Par.fromJSON(object.p1) : undefined,
      p2: isSet(object.p2) ? Par.fromJSON(object.p2) : undefined,
    };
  },

  toJSON(message: EDiv): unknown {
    const obj: any = {};
    if (message.p1 !== undefined) {
      obj.p1 = Par.toJSON(message.p1);
    }
    if (message.p2 !== undefined) {
      obj.p2 = Par.toJSON(message.p2);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<EDiv>, I>>(base?: I): EDiv {
    return EDiv.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<EDiv>, I>>(object: I): EDiv {
    const message = createBaseEDiv();
    message.p1 =
      object.p1 !== undefined && object.p1 !== null
        ? Par.fromPartial(object.p1)
        : undefined;
    message.p2 =
      object.p2 !== undefined && object.p2 !== null
        ? Par.fromPartial(object.p2)
        : undefined;
    return message;
  },
};

function createBaseEMod(): EMod {
  return { p1: undefined, p2: undefined };
}

export const EMod: MessageFns<EMod> = {
  encode(
    message: EMod,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.p1 !== undefined) {
      Par.encode(message.p1, writer.uint32(10).fork()).join();
    }
    if (message.p2 !== undefined) {
      Par.encode(message.p2, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EMod {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEMod();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.p1 = Par.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.p2 = Par.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EMod {
    return {
      p1: isSet(object.p1) ? Par.fromJSON(object.p1) : undefined,
      p2: isSet(object.p2) ? Par.fromJSON(object.p2) : undefined,
    };
  },

  toJSON(message: EMod): unknown {
    const obj: any = {};
    if (message.p1 !== undefined) {
      obj.p1 = Par.toJSON(message.p1);
    }
    if (message.p2 !== undefined) {
      obj.p2 = Par.toJSON(message.p2);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<EMod>, I>>(base?: I): EMod {
    return EMod.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<EMod>, I>>(object: I): EMod {
    const message = createBaseEMod();
    message.p1 =
      object.p1 !== undefined && object.p1 !== null
        ? Par.fromPartial(object.p1)
        : undefined;
    message.p2 =
      object.p2 !== undefined && object.p2 !== null
        ? Par.fromPartial(object.p2)
        : undefined;
    return message;
  },
};

function createBaseEPlus(): EPlus {
  return { p1: undefined, p2: undefined };
}

export const EPlus: MessageFns<EPlus> = {
  encode(
    message: EPlus,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.p1 !== undefined) {
      Par.encode(message.p1, writer.uint32(10).fork()).join();
    }
    if (message.p2 !== undefined) {
      Par.encode(message.p2, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EPlus {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEPlus();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.p1 = Par.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.p2 = Par.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EPlus {
    return {
      p1: isSet(object.p1) ? Par.fromJSON(object.p1) : undefined,
      p2: isSet(object.p2) ? Par.fromJSON(object.p2) : undefined,
    };
  },

  toJSON(message: EPlus): unknown {
    const obj: any = {};
    if (message.p1 !== undefined) {
      obj.p1 = Par.toJSON(message.p1);
    }
    if (message.p2 !== undefined) {
      obj.p2 = Par.toJSON(message.p2);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<EPlus>, I>>(base?: I): EPlus {
    return EPlus.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<EPlus>, I>>(object: I): EPlus {
    const message = createBaseEPlus();
    message.p1 =
      object.p1 !== undefined && object.p1 !== null
        ? Par.fromPartial(object.p1)
        : undefined;
    message.p2 =
      object.p2 !== undefined && object.p2 !== null
        ? Par.fromPartial(object.p2)
        : undefined;
    return message;
  },
};

function createBaseEMinus(): EMinus {
  return { p1: undefined, p2: undefined };
}

export const EMinus: MessageFns<EMinus> = {
  encode(
    message: EMinus,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.p1 !== undefined) {
      Par.encode(message.p1, writer.uint32(10).fork()).join();
    }
    if (message.p2 !== undefined) {
      Par.encode(message.p2, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EMinus {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEMinus();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.p1 = Par.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.p2 = Par.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EMinus {
    return {
      p1: isSet(object.p1) ? Par.fromJSON(object.p1) : undefined,
      p2: isSet(object.p2) ? Par.fromJSON(object.p2) : undefined,
    };
  },

  toJSON(message: EMinus): unknown {
    const obj: any = {};
    if (message.p1 !== undefined) {
      obj.p1 = Par.toJSON(message.p1);
    }
    if (message.p2 !== undefined) {
      obj.p2 = Par.toJSON(message.p2);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<EMinus>, I>>(base?: I): EMinus {
    return EMinus.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<EMinus>, I>>(object: I): EMinus {
    const message = createBaseEMinus();
    message.p1 =
      object.p1 !== undefined && object.p1 !== null
        ? Par.fromPartial(object.p1)
        : undefined;
    message.p2 =
      object.p2 !== undefined && object.p2 !== null
        ? Par.fromPartial(object.p2)
        : undefined;
    return message;
  },
};

function createBaseELt(): ELt {
  return { p1: undefined, p2: undefined };
}

export const ELt: MessageFns<ELt> = {
  encode(
    message: ELt,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.p1 !== undefined) {
      Par.encode(message.p1, writer.uint32(10).fork()).join();
    }
    if (message.p2 !== undefined) {
      Par.encode(message.p2, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ELt {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseELt();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.p1 = Par.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.p2 = Par.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ELt {
    return {
      p1: isSet(object.p1) ? Par.fromJSON(object.p1) : undefined,
      p2: isSet(object.p2) ? Par.fromJSON(object.p2) : undefined,
    };
  },

  toJSON(message: ELt): unknown {
    const obj: any = {};
    if (message.p1 !== undefined) {
      obj.p1 = Par.toJSON(message.p1);
    }
    if (message.p2 !== undefined) {
      obj.p2 = Par.toJSON(message.p2);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ELt>, I>>(base?: I): ELt {
    return ELt.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ELt>, I>>(object: I): ELt {
    const message = createBaseELt();
    message.p1 =
      object.p1 !== undefined && object.p1 !== null
        ? Par.fromPartial(object.p1)
        : undefined;
    message.p2 =
      object.p2 !== undefined && object.p2 !== null
        ? Par.fromPartial(object.p2)
        : undefined;
    return message;
  },
};

function createBaseELte(): ELte {
  return { p1: undefined, p2: undefined };
}

export const ELte: MessageFns<ELte> = {
  encode(
    message: ELte,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.p1 !== undefined) {
      Par.encode(message.p1, writer.uint32(10).fork()).join();
    }
    if (message.p2 !== undefined) {
      Par.encode(message.p2, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ELte {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseELte();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.p1 = Par.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.p2 = Par.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ELte {
    return {
      p1: isSet(object.p1) ? Par.fromJSON(object.p1) : undefined,
      p2: isSet(object.p2) ? Par.fromJSON(object.p2) : undefined,
    };
  },

  toJSON(message: ELte): unknown {
    const obj: any = {};
    if (message.p1 !== undefined) {
      obj.p1 = Par.toJSON(message.p1);
    }
    if (message.p2 !== undefined) {
      obj.p2 = Par.toJSON(message.p2);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ELte>, I>>(base?: I): ELte {
    return ELte.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ELte>, I>>(object: I): ELte {
    const message = createBaseELte();
    message.p1 =
      object.p1 !== undefined && object.p1 !== null
        ? Par.fromPartial(object.p1)
        : undefined;
    message.p2 =
      object.p2 !== undefined && object.p2 !== null
        ? Par.fromPartial(object.p2)
        : undefined;
    return message;
  },
};

function createBaseEGt(): EGt {
  return { p1: undefined, p2: undefined };
}

export const EGt: MessageFns<EGt> = {
  encode(
    message: EGt,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.p1 !== undefined) {
      Par.encode(message.p1, writer.uint32(10).fork()).join();
    }
    if (message.p2 !== undefined) {
      Par.encode(message.p2, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EGt {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEGt();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.p1 = Par.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.p2 = Par.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EGt {
    return {
      p1: isSet(object.p1) ? Par.fromJSON(object.p1) : undefined,
      p2: isSet(object.p2) ? Par.fromJSON(object.p2) : undefined,
    };
  },

  toJSON(message: EGt): unknown {
    const obj: any = {};
    if (message.p1 !== undefined) {
      obj.p1 = Par.toJSON(message.p1);
    }
    if (message.p2 !== undefined) {
      obj.p2 = Par.toJSON(message.p2);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<EGt>, I>>(base?: I): EGt {
    return EGt.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<EGt>, I>>(object: I): EGt {
    const message = createBaseEGt();
    message.p1 =
      object.p1 !== undefined && object.p1 !== null
        ? Par.fromPartial(object.p1)
        : undefined;
    message.p2 =
      object.p2 !== undefined && object.p2 !== null
        ? Par.fromPartial(object.p2)
        : undefined;
    return message;
  },
};

function createBaseEGte(): EGte {
  return { p1: undefined, p2: undefined };
}

export const EGte: MessageFns<EGte> = {
  encode(
    message: EGte,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.p1 !== undefined) {
      Par.encode(message.p1, writer.uint32(10).fork()).join();
    }
    if (message.p2 !== undefined) {
      Par.encode(message.p2, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EGte {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEGte();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.p1 = Par.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.p2 = Par.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EGte {
    return {
      p1: isSet(object.p1) ? Par.fromJSON(object.p1) : undefined,
      p2: isSet(object.p2) ? Par.fromJSON(object.p2) : undefined,
    };
  },

  toJSON(message: EGte): unknown {
    const obj: any = {};
    if (message.p1 !== undefined) {
      obj.p1 = Par.toJSON(message.p1);
    }
    if (message.p2 !== undefined) {
      obj.p2 = Par.toJSON(message.p2);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<EGte>, I>>(base?: I): EGte {
    return EGte.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<EGte>, I>>(object: I): EGte {
    const message = createBaseEGte();
    message.p1 =
      object.p1 !== undefined && object.p1 !== null
        ? Par.fromPartial(object.p1)
        : undefined;
    message.p2 =
      object.p2 !== undefined && object.p2 !== null
        ? Par.fromPartial(object.p2)
        : undefined;
    return message;
  },
};

function createBaseEEq(): EEq {
  return { p1: undefined, p2: undefined };
}

export const EEq: MessageFns<EEq> = {
  encode(
    message: EEq,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.p1 !== undefined) {
      Par.encode(message.p1, writer.uint32(10).fork()).join();
    }
    if (message.p2 !== undefined) {
      Par.encode(message.p2, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EEq {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEEq();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.p1 = Par.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.p2 = Par.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EEq {
    return {
      p1: isSet(object.p1) ? Par.fromJSON(object.p1) : undefined,
      p2: isSet(object.p2) ? Par.fromJSON(object.p2) : undefined,
    };
  },

  toJSON(message: EEq): unknown {
    const obj: any = {};
    if (message.p1 !== undefined) {
      obj.p1 = Par.toJSON(message.p1);
    }
    if (message.p2 !== undefined) {
      obj.p2 = Par.toJSON(message.p2);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<EEq>, I>>(base?: I): EEq {
    return EEq.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<EEq>, I>>(object: I): EEq {
    const message = createBaseEEq();
    message.p1 =
      object.p1 !== undefined && object.p1 !== null
        ? Par.fromPartial(object.p1)
        : undefined;
    message.p2 =
      object.p2 !== undefined && object.p2 !== null
        ? Par.fromPartial(object.p2)
        : undefined;
    return message;
  },
};

function createBaseENeq(): ENeq {
  return { p1: undefined, p2: undefined };
}

export const ENeq: MessageFns<ENeq> = {
  encode(
    message: ENeq,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.p1 !== undefined) {
      Par.encode(message.p1, writer.uint32(10).fork()).join();
    }
    if (message.p2 !== undefined) {
      Par.encode(message.p2, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ENeq {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseENeq();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.p1 = Par.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.p2 = Par.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ENeq {
    return {
      p1: isSet(object.p1) ? Par.fromJSON(object.p1) : undefined,
      p2: isSet(object.p2) ? Par.fromJSON(object.p2) : undefined,
    };
  },

  toJSON(message: ENeq): unknown {
    const obj: any = {};
    if (message.p1 !== undefined) {
      obj.p1 = Par.toJSON(message.p1);
    }
    if (message.p2 !== undefined) {
      obj.p2 = Par.toJSON(message.p2);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ENeq>, I>>(base?: I): ENeq {
    return ENeq.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ENeq>, I>>(object: I): ENeq {
    const message = createBaseENeq();
    message.p1 =
      object.p1 !== undefined && object.p1 !== null
        ? Par.fromPartial(object.p1)
        : undefined;
    message.p2 =
      object.p2 !== undefined && object.p2 !== null
        ? Par.fromPartial(object.p2)
        : undefined;
    return message;
  },
};

function createBaseEAnd(): EAnd {
  return { p1: undefined, p2: undefined };
}

export const EAnd: MessageFns<EAnd> = {
  encode(
    message: EAnd,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.p1 !== undefined) {
      Par.encode(message.p1, writer.uint32(10).fork()).join();
    }
    if (message.p2 !== undefined) {
      Par.encode(message.p2, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EAnd {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEAnd();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.p1 = Par.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.p2 = Par.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EAnd {
    return {
      p1: isSet(object.p1) ? Par.fromJSON(object.p1) : undefined,
      p2: isSet(object.p2) ? Par.fromJSON(object.p2) : undefined,
    };
  },

  toJSON(message: EAnd): unknown {
    const obj: any = {};
    if (message.p1 !== undefined) {
      obj.p1 = Par.toJSON(message.p1);
    }
    if (message.p2 !== undefined) {
      obj.p2 = Par.toJSON(message.p2);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<EAnd>, I>>(base?: I): EAnd {
    return EAnd.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<EAnd>, I>>(object: I): EAnd {
    const message = createBaseEAnd();
    message.p1 =
      object.p1 !== undefined && object.p1 !== null
        ? Par.fromPartial(object.p1)
        : undefined;
    message.p2 =
      object.p2 !== undefined && object.p2 !== null
        ? Par.fromPartial(object.p2)
        : undefined;
    return message;
  },
};

function createBaseEOr(): EOr {
  return { p1: undefined, p2: undefined };
}

export const EOr: MessageFns<EOr> = {
  encode(
    message: EOr,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.p1 !== undefined) {
      Par.encode(message.p1, writer.uint32(10).fork()).join();
    }
    if (message.p2 !== undefined) {
      Par.encode(message.p2, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EOr {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEOr();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.p1 = Par.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.p2 = Par.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EOr {
    return {
      p1: isSet(object.p1) ? Par.fromJSON(object.p1) : undefined,
      p2: isSet(object.p2) ? Par.fromJSON(object.p2) : undefined,
    };
  },

  toJSON(message: EOr): unknown {
    const obj: any = {};
    if (message.p1 !== undefined) {
      obj.p1 = Par.toJSON(message.p1);
    }
    if (message.p2 !== undefined) {
      obj.p2 = Par.toJSON(message.p2);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<EOr>, I>>(base?: I): EOr {
    return EOr.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<EOr>, I>>(object: I): EOr {
    const message = createBaseEOr();
    message.p1 =
      object.p1 !== undefined && object.p1 !== null
        ? Par.fromPartial(object.p1)
        : undefined;
    message.p2 =
      object.p2 !== undefined && object.p2 !== null
        ? Par.fromPartial(object.p2)
        : undefined;
    return message;
  },
};

function createBaseEMatches(): EMatches {
  return { target: undefined, pattern: undefined };
}

export const EMatches: MessageFns<EMatches> = {
  encode(
    message: EMatches,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.target !== undefined) {
      Par.encode(message.target, writer.uint32(10).fork()).join();
    }
    if (message.pattern !== undefined) {
      Par.encode(message.pattern, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EMatches {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEMatches();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.target = Par.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.pattern = Par.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EMatches {
    return {
      target: isSet(object.target) ? Par.fromJSON(object.target) : undefined,
      pattern: isSet(object.pattern) ? Par.fromJSON(object.pattern) : undefined,
    };
  },

  toJSON(message: EMatches): unknown {
    const obj: any = {};
    if (message.target !== undefined) {
      obj.target = Par.toJSON(message.target);
    }
    if (message.pattern !== undefined) {
      obj.pattern = Par.toJSON(message.pattern);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<EMatches>, I>>(base?: I): EMatches {
    return EMatches.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<EMatches>, I>>(object: I): EMatches {
    const message = createBaseEMatches();
    message.target =
      object.target !== undefined && object.target !== null
        ? Par.fromPartial(object.target)
        : undefined;
    message.pattern =
      object.pattern !== undefined && object.pattern !== null
        ? Par.fromPartial(object.pattern)
        : undefined;
    return message;
  },
};

function createBaseEPercentPercent(): EPercentPercent {
  return { p1: undefined, p2: undefined };
}

export const EPercentPercent: MessageFns<EPercentPercent> = {
  encode(
    message: EPercentPercent,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.p1 !== undefined) {
      Par.encode(message.p1, writer.uint32(10).fork()).join();
    }
    if (message.p2 !== undefined) {
      Par.encode(message.p2, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EPercentPercent {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEPercentPercent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.p1 = Par.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.p2 = Par.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EPercentPercent {
    return {
      p1: isSet(object.p1) ? Par.fromJSON(object.p1) : undefined,
      p2: isSet(object.p2) ? Par.fromJSON(object.p2) : undefined,
    };
  },

  toJSON(message: EPercentPercent): unknown {
    const obj: any = {};
    if (message.p1 !== undefined) {
      obj.p1 = Par.toJSON(message.p1);
    }
    if (message.p2 !== undefined) {
      obj.p2 = Par.toJSON(message.p2);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<EPercentPercent>, I>>(
    base?: I,
  ): EPercentPercent {
    return EPercentPercent.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<EPercentPercent>, I>>(
    object: I,
  ): EPercentPercent {
    const message = createBaseEPercentPercent();
    message.p1 =
      object.p1 !== undefined && object.p1 !== null
        ? Par.fromPartial(object.p1)
        : undefined;
    message.p2 =
      object.p2 !== undefined && object.p2 !== null
        ? Par.fromPartial(object.p2)
        : undefined;
    return message;
  },
};

function createBaseEPlusPlus(): EPlusPlus {
  return { p1: undefined, p2: undefined };
}

export const EPlusPlus: MessageFns<EPlusPlus> = {
  encode(
    message: EPlusPlus,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.p1 !== undefined) {
      Par.encode(message.p1, writer.uint32(10).fork()).join();
    }
    if (message.p2 !== undefined) {
      Par.encode(message.p2, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EPlusPlus {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEPlusPlus();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.p1 = Par.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.p2 = Par.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EPlusPlus {
    return {
      p1: isSet(object.p1) ? Par.fromJSON(object.p1) : undefined,
      p2: isSet(object.p2) ? Par.fromJSON(object.p2) : undefined,
    };
  },

  toJSON(message: EPlusPlus): unknown {
    const obj: any = {};
    if (message.p1 !== undefined) {
      obj.p1 = Par.toJSON(message.p1);
    }
    if (message.p2 !== undefined) {
      obj.p2 = Par.toJSON(message.p2);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<EPlusPlus>, I>>(base?: I): EPlusPlus {
    return EPlusPlus.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<EPlusPlus>, I>>(
    object: I,
  ): EPlusPlus {
    const message = createBaseEPlusPlus();
    message.p1 =
      object.p1 !== undefined && object.p1 !== null
        ? Par.fromPartial(object.p1)
        : undefined;
    message.p2 =
      object.p2 !== undefined && object.p2 !== null
        ? Par.fromPartial(object.p2)
        : undefined;
    return message;
  },
};

function createBaseEMinusMinus(): EMinusMinus {
  return { p1: undefined, p2: undefined };
}

export const EMinusMinus: MessageFns<EMinusMinus> = {
  encode(
    message: EMinusMinus,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.p1 !== undefined) {
      Par.encode(message.p1, writer.uint32(10).fork()).join();
    }
    if (message.p2 !== undefined) {
      Par.encode(message.p2, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EMinusMinus {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEMinusMinus();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.p1 = Par.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.p2 = Par.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EMinusMinus {
    return {
      p1: isSet(object.p1) ? Par.fromJSON(object.p1) : undefined,
      p2: isSet(object.p2) ? Par.fromJSON(object.p2) : undefined,
    };
  },

  toJSON(message: EMinusMinus): unknown {
    const obj: any = {};
    if (message.p1 !== undefined) {
      obj.p1 = Par.toJSON(message.p1);
    }
    if (message.p2 !== undefined) {
      obj.p2 = Par.toJSON(message.p2);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<EMinusMinus>, I>>(base?: I): EMinusMinus {
    return EMinusMinus.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<EMinusMinus>, I>>(
    object: I,
  ): EMinusMinus {
    const message = createBaseEMinusMinus();
    message.p1 =
      object.p1 !== undefined && object.p1 !== null
        ? Par.fromPartial(object.p1)
        : undefined;
    message.p2 =
      object.p2 !== undefined && object.p2 !== null
        ? Par.fromPartial(object.p2)
        : undefined;
    return message;
  },
};

function createBaseConnective(): Connective {
  return {
    connAndBody: undefined,
    connOrBody: undefined,
    connNotBody: undefined,
    varRefBody: undefined,
    connBool: undefined,
    connInt: undefined,
    connString: undefined,
    connUri: undefined,
    connByteArray: undefined,
  };
}

export const Connective: MessageFns<Connective> = {
  encode(
    message: Connective,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.connAndBody !== undefined) {
      ConnectiveBody.encode(
        message.connAndBody,
        writer.uint32(10).fork(),
      ).join();
    }
    if (message.connOrBody !== undefined) {
      ConnectiveBody.encode(
        message.connOrBody,
        writer.uint32(18).fork(),
      ).join();
    }
    if (message.connNotBody !== undefined) {
      Par.encode(message.connNotBody, writer.uint32(26).fork()).join();
    }
    if (message.varRefBody !== undefined) {
      VarRef.encode(message.varRefBody, writer.uint32(34).fork()).join();
    }
    if (message.connBool !== undefined) {
      writer.uint32(40).bool(message.connBool);
    }
    if (message.connInt !== undefined) {
      writer.uint32(48).bool(message.connInt);
    }
    if (message.connString !== undefined) {
      writer.uint32(56).bool(message.connString);
    }
    if (message.connUri !== undefined) {
      writer.uint32(64).bool(message.connUri);
    }
    if (message.connByteArray !== undefined) {
      writer.uint32(72).bool(message.connByteArray);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Connective {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseConnective();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.connAndBody = ConnectiveBody.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.connOrBody = ConnectiveBody.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.connNotBody = Par.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.varRefBody = VarRef.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.connBool = reader.bool();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.connInt = reader.bool();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.connString = reader.bool();
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.connUri = reader.bool();
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.connByteArray = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Connective {
    return {
      connAndBody: isSet(object.connAndBody)
        ? ConnectiveBody.fromJSON(object.connAndBody)
        : undefined,
      connOrBody: isSet(object.connOrBody)
        ? ConnectiveBody.fromJSON(object.connOrBody)
        : undefined,
      connNotBody: isSet(object.connNotBody)
        ? Par.fromJSON(object.connNotBody)
        : undefined,
      varRefBody: isSet(object.varRefBody)
        ? VarRef.fromJSON(object.varRefBody)
        : undefined,
      connBool: isSet(object.connBool)
        ? globalThis.Boolean(object.connBool)
        : undefined,
      connInt: isSet(object.connInt)
        ? globalThis.Boolean(object.connInt)
        : undefined,
      connString: isSet(object.connString)
        ? globalThis.Boolean(object.connString)
        : undefined,
      connUri: isSet(object.connUri)
        ? globalThis.Boolean(object.connUri)
        : undefined,
      connByteArray: isSet(object.connByteArray)
        ? globalThis.Boolean(object.connByteArray)
        : undefined,
    };
  },

  toJSON(message: Connective): unknown {
    const obj: any = {};
    if (message.connAndBody !== undefined) {
      obj.connAndBody = ConnectiveBody.toJSON(message.connAndBody);
    }
    if (message.connOrBody !== undefined) {
      obj.connOrBody = ConnectiveBody.toJSON(message.connOrBody);
    }
    if (message.connNotBody !== undefined) {
      obj.connNotBody = Par.toJSON(message.connNotBody);
    }
    if (message.varRefBody !== undefined) {
      obj.varRefBody = VarRef.toJSON(message.varRefBody);
    }
    if (message.connBool !== undefined) {
      obj.connBool = message.connBool;
    }
    if (message.connInt !== undefined) {
      obj.connInt = message.connInt;
    }
    if (message.connString !== undefined) {
      obj.connString = message.connString;
    }
    if (message.connUri !== undefined) {
      obj.connUri = message.connUri;
    }
    if (message.connByteArray !== undefined) {
      obj.connByteArray = message.connByteArray;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Connective>, I>>(base?: I): Connective {
    return Connective.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Connective>, I>>(
    object: I,
  ): Connective {
    const message = createBaseConnective();
    message.connAndBody =
      object.connAndBody !== undefined && object.connAndBody !== null
        ? ConnectiveBody.fromPartial(object.connAndBody)
        : undefined;
    message.connOrBody =
      object.connOrBody !== undefined && object.connOrBody !== null
        ? ConnectiveBody.fromPartial(object.connOrBody)
        : undefined;
    message.connNotBody =
      object.connNotBody !== undefined && object.connNotBody !== null
        ? Par.fromPartial(object.connNotBody)
        : undefined;
    message.varRefBody =
      object.varRefBody !== undefined && object.varRefBody !== null
        ? VarRef.fromPartial(object.varRefBody)
        : undefined;
    message.connBool = object.connBool ?? undefined;
    message.connInt = object.connInt ?? undefined;
    message.connString = object.connString ?? undefined;
    message.connUri = object.connUri ?? undefined;
    message.connByteArray = object.connByteArray ?? undefined;
    return message;
  },
};

function createBaseVarRef(): VarRef {
  return { index: 0, depth: 0 };
}

export const VarRef: MessageFns<VarRef> = {
  encode(
    message: VarRef,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.index !== 0) {
      writer.uint32(8).sint32(message.index);
    }
    if (message.depth !== 0) {
      writer.uint32(16).sint32(message.depth);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): VarRef {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVarRef();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.index = reader.sint32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.depth = reader.sint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): VarRef {
    return {
      index: isSet(object.index) ? globalThis.Number(object.index) : 0,
      depth: isSet(object.depth) ? globalThis.Number(object.depth) : 0,
    };
  },

  toJSON(message: VarRef): unknown {
    const obj: any = {};
    if (message.index !== 0) {
      obj.index = Math.round(message.index);
    }
    if (message.depth !== 0) {
      obj.depth = Math.round(message.depth);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<VarRef>, I>>(base?: I): VarRef {
    return VarRef.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<VarRef>, I>>(object: I): VarRef {
    const message = createBaseVarRef();
    message.index = object.index ?? 0;
    message.depth = object.depth ?? 0;
    return message;
  },
};

function createBaseConnectiveBody(): ConnectiveBody {
  return { ps: [] };
}

export const ConnectiveBody: MessageFns<ConnectiveBody> = {
  encode(
    message: ConnectiveBody,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    for (const v of message.ps) {
      Par.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ConnectiveBody {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseConnectiveBody();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.ps.push(Par.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ConnectiveBody {
    return {
      ps: globalThis.Array.isArray(object?.ps)
        ? object.ps.map((e: any) => Par.fromJSON(e))
        : [],
    };
  },

  toJSON(message: ConnectiveBody): unknown {
    const obj: any = {};
    if (message.ps?.length) {
      obj.ps = message.ps.map((e) => Par.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ConnectiveBody>, I>>(
    base?: I,
  ): ConnectiveBody {
    return ConnectiveBody.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ConnectiveBody>, I>>(
    object: I,
  ): ConnectiveBody {
    const message = createBaseConnectiveBody();
    message.ps = object.ps?.map((e) => Par.fromPartial(e)) || [];
    return message;
  },
};

function createBaseDeployId(): DeployId {
  return { sig: new Uint8Array(0) };
}

export const DeployId: MessageFns<DeployId> = {
  encode(
    message: DeployId,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.sig.length !== 0) {
      writer.uint32(10).bytes(message.sig);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeployId {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeployId();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.sig = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeployId {
    return {
      sig: isSet(object.sig) ? bytesFromBase64(object.sig) : new Uint8Array(0),
    };
  },

  toJSON(message: DeployId): unknown {
    const obj: any = {};
    if (message.sig.length !== 0) {
      obj.sig = base64FromBytes(message.sig);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DeployId>, I>>(base?: I): DeployId {
    return DeployId.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DeployId>, I>>(object: I): DeployId {
    const message = createBaseDeployId();
    message.sig = object.sig ?? new Uint8Array(0);
    return message;
  },
};

function createBaseDeployerId(): DeployerId {
  return { publicKey: new Uint8Array(0) };
}

export const DeployerId: MessageFns<DeployerId> = {
  encode(
    message: DeployerId,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.publicKey.length !== 0) {
      writer.uint32(10).bytes(message.publicKey);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeployerId {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeployerId();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.publicKey = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeployerId {
    return {
      publicKey: isSet(object.publicKey)
        ? bytesFromBase64(object.publicKey)
        : new Uint8Array(0),
    };
  },

  toJSON(message: DeployerId): unknown {
    const obj: any = {};
    if (message.publicKey.length !== 0) {
      obj.publicKey = base64FromBytes(message.publicKey);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DeployerId>, I>>(base?: I): DeployerId {
    return DeployerId.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DeployerId>, I>>(
    object: I,
  ): DeployerId {
    const message = createBaseDeployerId();
    message.publicKey = object.publicKey ?? new Uint8Array(0);
    return message;
  },
};

function createBaseGUnforgeable(): GUnforgeable {
  return {
    gPrivateBody: undefined,
    gDeployIdBody: undefined,
    gDeployerIdBody: undefined,
    gSysAuthTokenBody: undefined,
  };
}

export const GUnforgeable: MessageFns<GUnforgeable> = {
  encode(
    message: GUnforgeable,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.gPrivateBody !== undefined) {
      GPrivate.encode(message.gPrivateBody, writer.uint32(10).fork()).join();
    }
    if (message.gDeployIdBody !== undefined) {
      GDeployId.encode(message.gDeployIdBody, writer.uint32(18).fork()).join();
    }
    if (message.gDeployerIdBody !== undefined) {
      GDeployerId.encode(
        message.gDeployerIdBody,
        writer.uint32(26).fork(),
      ).join();
    }
    if (message.gSysAuthTokenBody !== undefined) {
      GSysAuthToken.encode(
        message.gSysAuthTokenBody,
        writer.uint32(34).fork(),
      ).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GUnforgeable {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGUnforgeable();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.gPrivateBody = GPrivate.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.gDeployIdBody = GDeployId.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.gDeployerIdBody = GDeployerId.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.gSysAuthTokenBody = GSysAuthToken.decode(
            reader,
            reader.uint32(),
          );
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GUnforgeable {
    return {
      gPrivateBody: isSet(object.gPrivateBody)
        ? GPrivate.fromJSON(object.gPrivateBody)
        : undefined,
      gDeployIdBody: isSet(object.gDeployIdBody)
        ? GDeployId.fromJSON(object.gDeployIdBody)
        : undefined,
      gDeployerIdBody: isSet(object.gDeployerIdBody)
        ? GDeployerId.fromJSON(object.gDeployerIdBody)
        : undefined,
      gSysAuthTokenBody: isSet(object.gSysAuthTokenBody)
        ? GSysAuthToken.fromJSON(object.gSysAuthTokenBody)
        : undefined,
    };
  },

  toJSON(message: GUnforgeable): unknown {
    const obj: any = {};
    if (message.gPrivateBody !== undefined) {
      obj.gPrivateBody = GPrivate.toJSON(message.gPrivateBody);
    }
    if (message.gDeployIdBody !== undefined) {
      obj.gDeployIdBody = GDeployId.toJSON(message.gDeployIdBody);
    }
    if (message.gDeployerIdBody !== undefined) {
      obj.gDeployerIdBody = GDeployerId.toJSON(message.gDeployerIdBody);
    }
    if (message.gSysAuthTokenBody !== undefined) {
      obj.gSysAuthTokenBody = GSysAuthToken.toJSON(message.gSysAuthTokenBody);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GUnforgeable>, I>>(
    base?: I,
  ): GUnforgeable {
    return GUnforgeable.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GUnforgeable>, I>>(
    object: I,
  ): GUnforgeable {
    const message = createBaseGUnforgeable();
    message.gPrivateBody =
      object.gPrivateBody !== undefined && object.gPrivateBody !== null
        ? GPrivate.fromPartial(object.gPrivateBody)
        : undefined;
    message.gDeployIdBody =
      object.gDeployIdBody !== undefined && object.gDeployIdBody !== null
        ? GDeployId.fromPartial(object.gDeployIdBody)
        : undefined;
    message.gDeployerIdBody =
      object.gDeployerIdBody !== undefined && object.gDeployerIdBody !== null
        ? GDeployerId.fromPartial(object.gDeployerIdBody)
        : undefined;
    message.gSysAuthTokenBody =
      object.gSysAuthTokenBody !== undefined &&
      object.gSysAuthTokenBody !== null
        ? GSysAuthToken.fromPartial(object.gSysAuthTokenBody)
        : undefined;
    return message;
  },
};

function createBaseGPrivate(): GPrivate {
  return { id: new Uint8Array(0) };
}

export const GPrivate: MessageFns<GPrivate> = {
  encode(
    message: GPrivate,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.id.length !== 0) {
      writer.uint32(10).bytes(message.id);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GPrivate {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGPrivate();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GPrivate {
    return {
      id: isSet(object.id) ? bytesFromBase64(object.id) : new Uint8Array(0),
    };
  },

  toJSON(message: GPrivate): unknown {
    const obj: any = {};
    if (message.id.length !== 0) {
      obj.id = base64FromBytes(message.id);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GPrivate>, I>>(base?: I): GPrivate {
    return GPrivate.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GPrivate>, I>>(object: I): GPrivate {
    const message = createBaseGPrivate();
    message.id = object.id ?? new Uint8Array(0);
    return message;
  },
};

function createBaseGDeployId(): GDeployId {
  return { sig: new Uint8Array(0) };
}

export const GDeployId: MessageFns<GDeployId> = {
  encode(
    message: GDeployId,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.sig.length !== 0) {
      writer.uint32(10).bytes(message.sig);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GDeployId {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGDeployId();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.sig = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GDeployId {
    return {
      sig: isSet(object.sig) ? bytesFromBase64(object.sig) : new Uint8Array(0),
    };
  },

  toJSON(message: GDeployId): unknown {
    const obj: any = {};
    if (message.sig.length !== 0) {
      obj.sig = base64FromBytes(message.sig);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GDeployId>, I>>(base?: I): GDeployId {
    return GDeployId.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GDeployId>, I>>(
    object: I,
  ): GDeployId {
    const message = createBaseGDeployId();
    message.sig = object.sig ?? new Uint8Array(0);
    return message;
  },
};

function createBaseGDeployerId(): GDeployerId {
  return { publicKey: new Uint8Array(0) };
}

export const GDeployerId: MessageFns<GDeployerId> = {
  encode(
    message: GDeployerId,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.publicKey.length !== 0) {
      writer.uint32(10).bytes(message.publicKey);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GDeployerId {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGDeployerId();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.publicKey = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GDeployerId {
    return {
      publicKey: isSet(object.publicKey)
        ? bytesFromBase64(object.publicKey)
        : new Uint8Array(0),
    };
  },

  toJSON(message: GDeployerId): unknown {
    const obj: any = {};
    if (message.publicKey.length !== 0) {
      obj.publicKey = base64FromBytes(message.publicKey);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GDeployerId>, I>>(base?: I): GDeployerId {
    return GDeployerId.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GDeployerId>, I>>(
    object: I,
  ): GDeployerId {
    const message = createBaseGDeployerId();
    message.publicKey = object.publicKey ?? new Uint8Array(0);
    return message;
  },
};

function createBaseGSysAuthToken(): GSysAuthToken {
  return {};
}

export const GSysAuthToken: MessageFns<GSysAuthToken> = {
  encode(
    _: GSysAuthToken,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GSysAuthToken {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGSysAuthToken();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): GSysAuthToken {
    return {};
  },

  toJSON(_: GSysAuthToken): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<GSysAuthToken>, I>>(
    base?: I,
  ): GSysAuthToken {
    return GSysAuthToken.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GSysAuthToken>, I>>(
    _: I,
  ): GSysAuthToken {
    const message = createBaseGSysAuthToken();
    return message;
  },
};

function bytesFromBase64(b64: string): Uint8Array {
  if ((globalThis as any).Buffer) {
    return Uint8Array.from(globalThis.Buffer.from(b64, "base64"));
  } else {
    const bin = globalThis.atob(b64);
    const arr = new Uint8Array(bin.length);
    for (let i = 0; i < bin.length; ++i) {
      arr[i] = bin.charCodeAt(i);
    }
    return arr;
  }
}

function base64FromBytes(arr: Uint8Array): string {
  if ((globalThis as any).Buffer) {
    return globalThis.Buffer.from(arr).toString("base64");
  } else {
    const bin: string[] = [];
    arr.forEach((byte) => {
      bin.push(globalThis.String.fromCharCode(byte));
    });
    return globalThis.btoa(bin.join(""));
  }
}

type Builtin =
  | Date
  | Function
  | Uint8Array
  | string
  | number
  | boolean
  | undefined;

export type DeepPartial<T> = T extends Builtin
  ? T
  : T extends globalThis.Array<infer U>
    ? globalThis.Array<DeepPartial<U>>
    : T extends ReadonlyArray<infer U>
      ? ReadonlyArray<DeepPartial<U>>
      : T extends {}
        ? { [K in keyof T]?: DeepPartial<T[K]> }
        : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin
  ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & {
      [K in Exclude<keyof I, KeysOfUnion<P>>]: never;
    };

function longToNumber(int64: { toString(): string }): number {
  const num = globalThis.Number(int64.toString());
  if (num > globalThis.Number.MAX_SAFE_INTEGER) {
    throw new globalThis.Error("Value is larger than Number.MAX_SAFE_INTEGER");
  }
  if (num < globalThis.Number.MIN_SAFE_INTEGER) {
    throw new globalThis.Error("Value is smaller than Number.MIN_SAFE_INTEGER");
  }
  return num;
}

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
